#!/usr/bin/perl -w
#
# ord: By Steven J. DeRose, 2007-10.
#
# 2007-11-22 sjd:  Accept control-char mnemonics as input. Getopt.
#     Add binary and long-name output.
# 2008-02-14 sjd: Multiple input chars. setupCharacterNames(). Unify $fmt.
#     Add longNames for G0 and G1. Add --g0, --g1. perl -w.
# 2008-09-03 sjd: Move to BSD. Improve doc.
# 2008-09-16 sjd: Better handling of Unicode input.
# 2010-01-06 sjd: Use 'charnames' to know Unicode names. Add --binary.
#     Make print utf-8 and actual Unicode character. Format binary better.
# 2010-05-03 sjd: perldoc. Unify formatting. Add Unix Jargon names, rest of
#     short names. Make user use "_" in.
# 2011-08-23 sjd: Add options to control each display form separately.
#     Start --cp1252.
# 2011-12-11 sjd: Add utf-8 output. Opt out of longNames (lists of
#     char names -- now using viacode instead).
# 2012-01-10 sjd: Cleanup. Lose internal 'longNames' lists.
# 2012-08-15 sjd: sjdUtils, and use getUTF8().
# 2013-06-17ff sjd: Add --entities, esp. HTML named ones. Add showUnicodeInfo().
# 2014-09-02: Clean up.
# 2015-08-15ff: Add formats PYTHONS, PYTHONU; rename format PYTHON to PYTHONN.
#     Finish --find. Display control-char mnemonics.
# 2016-01-08: Add --math and --digits.
# 2016-02-18: Add --regex, --listFormat CHART and HTML.
#     Warn if env LANG not utf-8. Recognize html entity names, C-J, ^J, etc.
# 2016-08-30: Get rid of sjdUtils.pm dependencies.
# 2016-09-05: Add --iconv option.
# 2018-01-19: Add --pairs.
# 2020-01-03: Add --minU.
#
# To do:
#     Port to Python, using CharDisplay.
#     Integrate remainder of 'chr' command functionality.
#         Catch utf8 hex input.
#     Way to print/export remaining Unicode char properties
#     Separate digits from math; handle the exceptions.
#     Make --typing show how to key on various systems?
#
use strict;
use Getopt::Long;
use charnames ':full';
use Unicode::UCD 'charscript';
use Unicode::UCD 'charblock';
use HTML::Entities;
use Encode;

#use sjdUtils;  # getUTF8(), isUnicodeCodePoint() are copied locally.

our $VERSION_DATE = "2018-01-19";

my @C0names     = ();
my @G0names     = ();
my @C1names     = ();
my @G1names     = ();

my $upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
my $lower = 'abcdefghijklmnopqrstuvwxyz';
my $URIchars = "!\$'()*+-._" . '0123456789' . $upper . $lower;
my $URIspecials = '/%&:;=?@';

my %unixJargon  = ();

setupShortCharacterNames();
setupUnixJargon();
my ($mathAlphabets, $mathGreeks, $digitSets, %mathMissing);
setupMathAlphabets();

my $binary      = 0;
my $chart       = 0;
my $cp1252      = 0;
my $decimal     = 1;
my $digits      = 0;
my $entities    = 1;
my $find        = 0;
my $C0 = my $C1 = 0;
my $G0 = my $G1 = 0;
my $hex         = 1;
my $iconv       = 0;
my $jargon      = 1;
my $listFormat  = "LITERAL";
my $literal     = 1;
my $long        = 1;
my $math        = 0;
my $maxU        = 65535;
my $minU        = 1;
my $octal       = 1;
my $pairs       = 0;
my $quiet       = 0;
my $regex       = 0;
my $short       = 0;
my $typing      = 1;
my $utf8        = 1;
my $verbose     = 0;


###############################################################################
# Process options
#
Getopt::Long::Configure ("ignore_case");
my $result = GetOptions(
    "binary!"             => \$binary,
    "c|chart"             => \$chart,
    "cp1252!"             => \$cp1252,
    "c0"                  => \$C0,
    "c1"                  => \$C1,
    "decimal!"            => \$decimal,
    "digits!"             => \$digits,
    "entities!"           => \$entities,
    "find!"               => \$find,
    "g0"                  => \$G0,
    "g1"                  => \$G1,
    "h|help|?"            => sub { system "perldoc $0"; },
    "hex!"                => \$hex,
    "iconv!"              => \$iconv,
    "jargon!"             => \$jargon,
    "listFormat=s"        => \$listFormat,
    "literal!"            => \$literal,
    "long!"               => \$long,
    "math!"               => \$math,
    "maxU=o"              => \$maxU,
    "minU=o"              => \$minU,
    "octal!"              => \$octal,
    "pairs!"              => \$pairs,
    "q|quiet!"            => \$quiet,
    "regex!"              => \$regex,
    "short!"              => \$short,
    "typing!"             => \$typing,
    "utf8!"               => \$utf8,
    "v|verbose+"          => \$verbose,
    "version"             => sub {
        warn "Version of $VERSION_DATE, by Steven J. DeRose.\n";
        exit;
    },
    );

($result) || die "Bad options.\n";

if ($regex) { $find = 1; }

my $iconvConverter = undef;
if ($iconv) {
    (sjdUtils::try_module("Text::Iconv")) || die
        "CPAN module TextIconv not found. Install it if you want --iconv.\n";
    $iconvConverter = Text::Iconv->new("utf8", "ascii//TRANSLIT");
}
$listFormat = uc($listFormat);

($minU < $maxU) || die
    "--minU must be less than --maxU.\n";

binmode(STDOUT, ":encoding(utf8)");
if ($ENV{"LANG"} !~ m/UTF-?8/i) {
	warn "Warning: LANG environment variable does not mention UTF-8.\n";
}

###############################################################################
#
if ($C0)       { showChart("c0"); exit; }
if ($G0)       { showChart("g0"); exit; }
if ($C1)       { showChart("c1"); exit; }
if ($G1)       { showChart("g1"); exit; }
if ($chart) {
    showChart("c0");
    showChart("g0");
    showChart("c1");
    showChart("g1");
    exit;
}
if ($digits) {
    my $prevName = "";
    for (my $i=0; $i<scalar(@{$digitSets}); $i++) {
        my $foo = $digitSets->[$i];
        my $cpA = $foo->[2];
        my $name = $foo->[0];
        printf("******* %s (U+%05x...):\n", uc($name), $cpA);
        my $msg = "";
        my $howMany = $foo->[4] - $foo->[3] + 1;
        if ($foo->[3] > 0) { $msg .= "   " x $foo->[3]; }
        for (my $n=0; $n<$howMany; $n++) {
            $msg .= sprintf("%3s", chr($cpA+$n));
        }
        print($msg . "\n");
        $prevName = $name;
    }
    exit;
}
if ($math) {
    print("\nLatin:\n");
    for (my $i=0; $i<scalar(@{$mathAlphabets}); $i++) {
        my $foo = $mathAlphabets->[$i];
        my $cpA = $foo->[2];
        printf("******* %s (U+%05x...):\n", uc($foo->[0]), $cpA);
        my $msg = my $extra = "";
        for (my $cp=$cpA; $cp<$cpA+26; $cp++) {
            if ($mathMissing{$cp}) {
                $msg .= '  -';
                $extra .= sprintf(
                    "%s is U+%05x, ",chr($mathMissing{$cp}),$mathMissing{$cp});
            }
            else { $msg .= sprintf("%3s", chr($cp)); }
        }
        print($msg . "\n");
        if ($extra) { print("    Also: $extra.\n"); }
    }
    print("\nGreek:\n");
    for (my $i=0; $i<scalar(@{$mathGreeks}); $i++) {
        my $foo = $mathGreeks->[$i];
        my $cpA = $foo->[2];
        printf("******* %s (U+%05x...):\n", uc($foo->[0]), $cpA);
        my $msg = "";
        for (my $cp=$cpA; $cp<$cpA+25; $cp++) {
            $msg .= sprintf("%3s", chr($cp));
        }
        print($msg . "\n");
    }
    exit;
}

if ($pairs) {
    print(qq@<html>
<head>
<style type="text/css">
    td.char { text-align:center; font-size:larger; }
</style>
</head>
<body>
<h1>Table of Unicode symmetric pairs (approximate)</h1>
<p>(generated by <i>ord</i>, by Steven J. DeRose)</p>

<table border="border">
@);
    # List cases we know we don't catch...
    my %otherPairs = (
        # Dingbats
        0x275B => 0x275C, 0x275D => 0x275E, 0x275F => 0x2760,
        0x2768 => 0x2769, 0x276A => 0x276B, 0x276C => 0x276D, 0x276E => 0x276F,
        0x2770 => 0x2771, 0x2772 => 0x2773, 0x2774 => 0x2775,
        0x27C8 => 0x27C9,
        # Domnos and mah jong tiles? Braille patterns?
        # Emoticons? smile/frown
        # Alchemicl aqua fortis vs. regis?
        # Punctuation (prime vs. reversed)
        0x2032 => 0x2035, 0x2033 => 0x2036, 0x2034 => 0x2037, # 2057 => ???
        # Logical/math inversion
        0x2200 => 0x2203, 0x2206 => 0x2206,
        0x2208 => 0x2209, 0x220A => 0x220D, 0x220B => 0x220C,
        0x22B2 => 0x22B3, 0x22B4 => 0x22B5,
        # Controls
        0x0001 => 0x0003, 0x0002 => 0x0002, 0x0005 => 0x0006, 0x000E => 0x000F,
        0x2401 => 0x2403, 0x2402 => 0x2402, 0x2405 => 0x2406, 0x240E => 0x240F,
        0x10140 => 0x10141,
    );
    while ((my $key, my $value) = each (%otherPairs)) {
        warn "$key: $value\n";
    }
    # Could do "-" special, but want to avoid "OPEN-HEADED ARROW", etc.
    my @leftWords = (
        'LEFT', 'LEFTWARDS', 'LEFTHAND', 'LEFT-POINTING', 'LEFT-FACING',
        'RIGHT-TO-LEFT', 'LEFT-HANDED', 'LEFT-SIDE',
        'OPEN', 'BEGIN', 'RISING', 'START',
        'LESS-THAN', 'PRECEDES', 'SUBSET', 'IMAGE', 'ELEMENT OF');
    my @rightWords = (
        'RIGHT', 'RIGHTWARDS', 'RIGHTHAND', 'RIGHT-POINTING', 'RIGHT-FACING',
        'LEFT-TO-RIGHT', 'RIGHT-HANDED', 'RIGHT-SIDE',
        'CLOSE', 'END', 'FALLING', 'END',
        'GREATER-THAN', 'SUCCEEDS', 'SUPERSET', 'ORIGINAL', 'CONTAINS');
    my $allExpr  = join("|", @leftWords) .'|' .  join("|", @rightWords);
    my $leftExpr = join("|", @leftWords);
    my $rightExpr = join("|", @rightWords);
    if (scalar(@leftWords) != scalar(@rightWords)) {
        die "Token count mismatch:\n$leftExpr\n$rightExpr\n";
    }

    my %pairMap = ();
    for (my $i=0; $i<scalar(@leftWords); $i++) {
        $pairMap{$leftWords[$i]} = $rightWords[$i];
        0 && warn sprintf("pairing '%s' => '%s'\n",
            $leftWords[$i], $pairMap{$leftWords[$i]});
    }
    my %lame = ( 0x0FD5=>1, 0x0FD6=>1, 0x0FD7=>1, 0x0FD8=>1 );

    my $nCandidates = 0;
    my @candidates = ();
    my %candidateIndex = ();
    for (my $i=$minU; $i<=$maxU; $i++) {
        if (exists $lame{$i}) { next; }
        if (!$quiet && ($i % 0x10000)==0) {
            warn sprintf("...starting Unicode plane at 0x%05x...\n", $i);
        }
        my $iname = charnames::viacode($i);
        if (!$iname) {
            # sprintf("Cannot get name for U+%04x.\n", $i);
            next;
        }
        # This isn't working...
        my $isOther = exists $otherPairs{$i};
        #($isOther) && warn "Got a special case: $i\n";
        if ($isOther || ($iname =~ m/\b($allExpr)\b/)) {
            if (!$iname) { warn "Not found\n"; }
            push(@candidates, [$i, $iname]);
            $candidateIndex{$iname} = $i;
            $nCandidates++;
        }
    }
    for (my $i=0; $i<$nCandidates; $i++) {
        my $lNum  = $candidates[$i][0];
        my $lName = $candidates[$i][1];
        ($lName) || die sprintf("*** item %d (of %d vs %d) has no name???\n",
                $i, $nCandidates, scalar(@candidates));
        if ($lName !~ m/\b($leftExpr)\b/) { next; }
        my $rName = $lName;
        $rName =~ s/\b($leftExpr)\b/{
            (exists $pairMap{$1}) || die "Missing left: ".$pairMap{$1}.".\n";
            $pairMap{$1}
        }/e;
        if (!exists $candidateIndex{$rName}) { next; }
        my $rNum = $candidateIndex{$rName};
        my $rec = "<tr>\n"
        . sprintf("    <td class='char'>&#x%04x;</td>\n", $lNum)
        . sprintf("    <td class='char'>&#x%04x;</td>\n", $rNum)
        . sprintf("    <td class='hex'>U+%04x</td>\n", $lNum)
        . sprintf("    <td class='hex'>U+%04x</td>\n", $rNum)
        . sprintf("    <td class='names'>%s\n                 <br \>%s</td>\n",
            $lName, $rName)
        . "</tr>\n";
        print $rec;
    }
    my $msg = sprintf(
        "%d character pairs found from 0 to U+%04x (see --maxU).",
        $nCandidates, $maxU);
    if ($nCandidates<1 && $maxU < 0x10000) {
        $msg .= " Trying raising --maxU to 0x1FFFF?";
    }

    print("</table>\n</body>\n</html>\n");
    exit;
} # pairs


###############################################################################
# (Data also available in tupleSets/cp1252.xsv, and in 'chr')
#
my %cp1252 = (
    0x80 => 0x20AC,   # EURO SIGN
    0x82 => 0x201A,   # SINGLE LOW-9 QUOTATION MARK
    0x83 => 0x0192,   # LATIN SMALL LETTER F WITH HOOK
    0x84 => 0x201E,   # DOUBLE LOW-9 QUOTATION MARK
    0x85 => 0x2026,   # HORIZONTAL ELLIPSIS
    0x86 => 0x2020,   # DAGGER
    0x87 => 0x2021,   # DOUBLE DAGGER
    0x88 => 0x02C6,   # MODIFIER LETTER CIRCUMFLEX ACCENT
    0x89 => 0x2030,   # PER MILLE SIGN
    0x8A => 0x0160,   # LATIN CAPITAL LETTER S WITH CARON
    0x8B => 0x2039,   # SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    0x8C => 0x0152,   # LATIN CAPITAL LIGATURE OE
    0x8E => 0x017D,   # LATIN CAPITAL LETTER Z WITH CARON
    0x91 => 0x2018,   # LEFT SINGLE QUOTATION MARK
    0x92 => 0x2019,   # RIGHT SINGLE QUOTATION MARK
    0x93 => 0x201C,   # LEFT DOUBLE QUOTATION MARK
    0x94 => 0x201D,   # RIGHT DOUBLE QUOTATION MARK
    0x95 => 0x2022,   # BULLET
    0x96 => 0x2013,   # EN DASH
    0x97 => 0x2014,   # EM DASH
    0x98 => 0x02DC,   # SMALL TILDE
    0x99 => 0x2122,   # TRADE MARK SIGN
    0x9A => 0x0161,   # LATIN SMALL LETTER S WITH CARON
    0x9B => 0x203A,   # SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    0x9C => 0x0153,   # LATIN SMALL LIGATURE OE
    0x9E => 0x017E,   # LATIN SMALL LETTER Z WITH CARON
    0x9F => 0x0178,   # LATIN CAPITAL LETTER Y WITH DIAERESIS
    );


###############################################################################
# (from sjdUtils.pm)
###############################################################################

# Return the UTF-8 byte sequences for a given character code,
# punctuated as needed to put in a URI.
#
sub getUTF8local {
    my ($n, $sep) = @_;
    if (!defined $sep) { $sep = "%"; }
    my $utf8 = Encode::encode('utf8', chr($n));
    my $ux = ();
    for (my $i=0; $i<length($utf8); $i++) {
        $ux .= sprintf("%s%02x", $sep, ord(substr($utf8,$i,1)));
    }
    return($ux);
}

sub isUnicodeCodePoint {
    my ($n) = @_;
    if ($n  < 0x000000 || $n  > 0x10FFFF ||
        $n == 0x00FFFE || $n == 0x00FFFF ||
        ($n >= 0x000080 && $n < 0x0000a0)
        ) { return(0); }
    return(1);
}


###############################################################################
###############################################################################
# Main
#
print "";
binmode(STDOUT,":utf8");

(scalar(@ARGV)) ||
    die "No character or mnemonic found (see -h for"
        . " information on hard-to-type characters).\n";

while (my $origName = shift) {
	my $name = $origName;
    my $n = 0;
    if (length($name) == 1) {
        $n = ord($name);
    }
    else { # Search for the name
    	my $entRef = '&'.$name.';';
    	my $c = HTML::Entities::decode($entRef);
        if ($c ne $entRef) {                # HTML entity (case sensitive!)
        	$n = ord($c);
        	printf("Found HTML entity name '$name' = U+%04x.\n", $n);
        }
        $name = uc($name);                  # C0 name?
        for (my $i=0; $i<scalar @C0names; $i++) {
            if ($C0names[$i] eq $name) { $n = $i; last; }
        }
        if (!$n) {                          # C1 name?
            for (my $i=0; $i<scalar @C1names; $i++) {
                if (lc($C1names[$i]) eq lc($name)) { $n = $i+128; last; }
            }
        }
        if (!$n) {                          # Long Unicode name
            (my $tname = uc($name)) =~ s/_+/ /g;
            $n = charnames::vianame($tname);
        }
        if (!$n) {                          # Unix Jargon name?
            for my $k (keys %unixJargon) {
                if ($unixJargon{$k} =~ m/\b$name\b/i) { $n = ord($k); last; }
            }
        }
        if (!$n) {                          # Number per se?
            if ($name =~ m/^0?x[0-9a-f]+$/i) {
                $name =~ s/0?x//i; $n = hex($name);
            }
            elsif ($name =~ m/^0[0-7]+$/)    { $n = oct($name); }
            elsif ($name =~ m/^[0-9]+$/)     { $n = $name - 0; }
        }
        if (!$n) {                          # ^J C-S
        	if ($name =~ m/^(\^|C-)([A-Z])$/) {
        		$n = index($upper, $2) + 1;
        	}
        }

        if (!$n || $find) {
            warn "Character mnemonic '$origName' (length "
                . length($name) . ") not found.\n";
            warn sprintf(
            	"    Searching for %s...\n", ($regex) ? "regex":"string");
            getMatchingUnicodeNames($name);
            next;
        }
    }
    showOne($n);
} # while

exit;


###############################################################################
#
sub showChart {
    my ($sectionName) = @_;
    ($verbose) && warn "Arg to showChart: $sectionName.\n";
    print "Character mnemonics and names:\n";

    if ($sectionName eq "c0") {
        print "C0 range:\n";
        for (my $n=0; $n<scalar @C0names; $n++) {
            print("\n");
            showOne($n);
        }
    }

    if ($sectionName eq "g0") {
        print "G0 range:\n";
        for (my $n=32; $n<128; $n++) {
            print("\n");
            showOne($n);
        }
    }

    if ($sectionName eq "c1") {
        print "\nC1 range:\n";
        for (my $n=128; $n<160; $n++) {
            print("\n");
            showOne($n);
        }
    }

    if ($sectionName eq "g1") {
        print "\nG1 range:\n";
        for (my $n=160; $n<255; $n++) {
            print("\n");
            showOne($n);
        }
    }
} # showChart


###############################################################################
#
sub getBinary {
    my ($n) = @_;
    my $rc = "";
    while ($n > 0) {
        my $n0 = $n & 0x0F;
        $n = $n>>4;
        my $n1 = $n & 0x0F;
        $n = $n>>4;
        $rc = sprintf("%04b_%04b %s", $n1, $n0, $rc);
    }
    $rc =~ s/\s+$//;
    return($rc);
}


###############################################################################
# Find all Unicode characters whose names contain the given string.
# This is slow. Could load once and then re-used, but probably it will
# rarely be used more than one or a few times per invocation.
#
sub getMatchingUnicodeNames {
    my ($name) = @_;
    my $nfound = 0;
    for (my $i=$minU; $i<=$maxU; $i++) {
        if (!$quiet && ($i % 0x10000)==0) {
            warn sprintf("...starting Unicode plane at 0x%05x...\n", $i);
        }
        my $iname = charnames::viacode($i);
        if (!$iname) { next; }
        if (!$regex) {
        	if (index($iname, uc($name)) < 0) { next; }
        }
        else {
        	if ($iname !~ m/$name/i) { next; }
        }
        $nfound++;
        if ($listFormat eq "PLAIN") {
            printf("U+%04x\t%s\n", $i, $iname);
        }
        elsif ($listFormat eq "LITERAL") {
            printf("U+%04x\t%s\t%s\n", $i, chr($i), $iname);
        }
        elsif ($listFormat eq "PERL") {
            printf("    0x%04x => '%s',\n", $i, $iname);
        }
        elsif ($listFormat eq "PYTHONN") {
            printf("    0x%04x: '%s',\n", $i, $iname);
        }
        elsif ($listFormat eq "PYTHONS") {
            printf("    unichr(0x%04x) +  # '%s'\n", $i, $iname);
        }
        elsif ($listFormat eq "PYTHONU") {
            printf("    u'\\u%04x' +  # '%s'\n", $i, $iname);
        }
        elsif ($listFormat eq "PYTHONC") {
            printf("    unichr(0x%04x): '%s',\n", $i, $iname);
        }
        elsif ($listFormat eq "INFO") {
        	print "\n";
        	showOne($i);
        }
        elsif ($listFormat eq "HTML") {
        	my $rec = "<tr>\n"
        	    . sprintf("    <td class='char'>&#x%04x;</td>\n", $i)
        	    . sprintf("    <td class='hex'>U+%04x</td>\n", $i)
        	    . sprintf("    <td class='name'>%s</td>\n", $iname)
        	    . "</tr>\n";
        	print $rec;
        }
        else {
            die "Unknown --listFormat '$listFormat'.\n";
        }
    }
    my $msg = sprintf(
        "%d matching characters found from 0 to U+%04x (see --maxU).",
        $nfound, $maxU);
    if ($nfound<1 && $maxU < 0x10000) {
        $msg .= " Trying raising --maxU to 0x1FFFF?";
    }
    print ("$msg\n");
    return;
}


###############################################################################
# Display just one character, with unified output formatting.
#
# Note: The widths aren't right for big unicode stuff.
#
sub showOne {
    my ($n) = @_;
    my $n2 = 0;
    my $c = chr($n);

    if ($cp1252 && $n>=128 && $n<160) {
        $n2 = cp1252ToUnicode($n);
    }
    if ($short) {
        pline(sprintf(" %6s", "'" . getShortName($n2 ? $n2:$n) . "'"));
    }

    if ($long) {
        showUnicodeInfo($n);
    }

    if ($literal) {
        my $lit = "";
        if ($n<32) {
            $lit = "(control: " . $C0names[$n];
            if ($n>0 && $n<26) { $lit .= ", ^" . substr($upper,$n,1); }
            $lit .= ") ";
        }
        else {
            $lit = $c;
        }
        pline("Literal:", $lit);
    }

    my $bases = "";
    if ($binary)  { $bases .= getBinary($n) . " ";    }
    if ($octal)   { $bases .= sprintf("o%04o ",$n);    }
    if ($decimal) { $bases .= sprintf("d%04d ",$n);    }
    if ($hex)     { $bases .= sprintf("x%04x ",$n);    }
    if ($bases) {
        pline("Bases:", $bases);
    }



    if ($utf8) {
        my $utf = getUTF8local($n2 ? $n2:$n, "\\x");
        my $uri = getUTF8local($n2 ? $n2:$n, "%");
        my $okURI = (index($URIchars, $c) >= 0) ? 1:0;
        pline("Unicode:", sprintf(
            "U+%04x, utf8 %s, URI %s",
            $n, $utf, ($okURI) ? "(ok)" : $uri));
    }

    if ($entities) {
        if ($n<32 && $n!=9 && $n!=10 && $n!=13) {
            pline("Entites:", "[not a legal XML character]");
        }
        else {
            my $entName = HTML::Entities::encode($c);
            if ($entName =~ m/^&#/) { $entName = "-NO HTML NAMED ENTITY-"; }
            pline("Entities:", sprintf("&#%d; &#x%x; %s", $n, $n, $entName));
        }
    }

    if ($iconv && $n>=128) {
        my $asc = $iconvConverter->convert($c);
        if (defined $asc && $asc) {
            pline("Nearest ASCII:", $asc);
        }
        else {
            pline("Nearest ASCII:", "[none]");
        }
    }

    if ($jargon && defined $unixJargon{$c}) {
        pline("Unix jargon:", $unixJargon{$c});
    }
} # showOne


sub pline {
    my ($label, $data) = @_;
    printf("    %-16s %s\n", $label, $data || "");
}

sub showUnicodeInfo {
    my ($n) = @_;
    if (!isUnicodeCodePoint($n)) {
        pline("WARNING:", "Not a Unicode code point");
    }
    else {
        pline("Unicode Name:", charnames::viacode($n) || "-NOT FOUND-");
        pline("Unicode Script: ", charscript(sprintf("U+%04x", $n)));
        pline("Unicode Block:  ",  charblock(sprintf("U+%04x", $n)));
    }
    my $pnum = $n >> 16;
    my $pname = "";
    if    ($pnum == 16) { $pname = "Supplementary Private Use Area B"; }
    elsif ($pnum == 15) { $pname = "Supplementary Private Use Area A"; }
    elsif ($pnum == 14) { $pname = "Supplementary Special-purpose"; }
    elsif ($pnum >=  3) { $pname = "Unassigned"; }
    elsif ($pnum ==  2) { $pname = "Supplementary Ideographic"; }
    elsif ($pnum ==  1) { $pname = "Supplementary Multilingual"; }
    elsif ($pnum ==  0) { $pname = "Basic Multilingual"; }
    else                { $pname = "-UNKNOWN-"; }
    pline("Unicode Plane:" , $pnum . ": " . $pname);

    if ($n == 0xEFBFBD) {
        pline("WARNING:", "UTF8 of U+FFFD (Replacement Character)?");
    }
} # showUnicodeInfo


###############################################################################
#
sub getShortName {
    my ($n) = @_;
    my $name = "";
    if ($n>=256) {
        return(charnames::viacode($n) ||"???");
    }
    else {
        if ($n < 32)     { $name = $C0names[$n];     }
        elsif ($n < 128) { $name = $G0names[$n-32];  }
        elsif ($n < 160) { $name = $C1names[$n-128]; }
        elsif ($n < 256) { $name = $G1names[$n-160]; }
    }
    return($name);
}


###############################################################################
# Define local names, in case we want shorter forms than viacode gives.
#
sub setupShortCharacterNames {
    @C0names = (
              "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
               "BS",  "HT",  "LF",  "VT",  "FF",  "CR",  "SO",  "SI",
              "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
              "CAN",  "EM", "SUB", "ESC",  "FS",  "GS",  "RS",  "US",
               "SP");

    @C1names = (
              "PAD", "HOP",  "BPH", "NBH", "IND", "NEL", "SSA", "ESA",
              "HTS", "HTJ",  "VTS", "PLD", "PLU",  "RI", "SS2", "SS3",
              "DCS", "PU1",  "PU2", "STS", "CCH",  "MW", "SPA", "EPA",
              "SOS", "SGCI", "SCI", "CSI",  "ST", "OSC",  "PM", "APC",
              "NBS");

    @G0names = (
        # 0x20
        "SPACE",
        "BANG",
        "QUOTATION MARK",
        "HASH",
        "DOLLAR",
        "GRAPES",
        "AMP",
        "POP",
        "LEFT PARENTHESIS",
        "RIGHT PARENTHESIS",
        "ASTERISK",
        "PLUS SIGN",
        "COMMA",
        "HYPHEN-MINUS",
        "FULL STOP",
        "SOLIDUS",

        # 0x30
        "DIGIT ZERO",
        "DIGIT ONE",
        "DIGIT TWO",
        "DIGIT THREE",
        "DIGIT FOUR",
        "DIGIT FIVE",
        "DIGIT SIX",
        "DIGIT SEVEN",
        "DIGIT EIGHT",
        "DIGIT NINE",
        "COLON",
        "SEMICOLON",
        "LESS-THAN SIGN",
        "EQUALS SIGN",
        "GREATER-THAN SIGN",
        "QUESTION MARK",

        # 0x40
        "COMMERCIAL AT",
        "LATIN CAPITAL LETTER A",
        "LATIN CAPITAL LETTER B",
        "LATIN CAPITAL LETTER C",
        "LATIN CAPITAL LETTER D",
        "LATIN CAPITAL LETTER E",
        "LATIN CAPITAL LETTER F",
        "LATIN CAPITAL LETTER G",
        "LATIN CAPITAL LETTER H",
        "LATIN CAPITAL LETTER I",
        "LATIN CAPITAL LETTER J",
        "LATIN CAPITAL LETTER K",
        "LATIN CAPITAL LETTER L",
        "LATIN CAPITAL LETTER M",
        "LATIN CAPITAL LETTER N",
        "LATIN CAPITAL LETTER O",

        # 0x50
        "LATIN CAPITAL LETTER P",
        "LATIN CAPITAL LETTER Q",
        "LATIN CAPITAL LETTER R",
        "LATIN CAPITAL LETTER S",
        "LATIN CAPITAL LETTER T",
        "LATIN CAPITAL LETTER U",
        "LATIN CAPITAL LETTER V",
        "LATIN CAPITAL LETTER W",
        "LATIN CAPITAL LETTER X",
        "LATIN CAPITAL LETTER Y",
        "LATIN CAPITAL LETTER Z",
        "LEFT SQUARE BRACKET",
        "REVERSE SOLIDUS",
        "RIGHT SQUARE BRACKET",
        "CIRCUMFLEX ACCENT",
        "LOW LINE",

        # 0x60
        "GRAVE ACCENT",
        "LATIN SMALL LETTER A",
        "LATIN SMALL LETTER B",
        "LATIN SMALL LETTER C",
        "LATIN SMALL LETTER D",
        "LATIN SMALL LETTER E",
        "LATIN SMALL LETTER F",
        "LATIN SMALL LETTER G",
        "LATIN SMALL LETTER H",
        "LATIN SMALL LETTER I",
        "LATIN SMALL LETTER J",
        "LATIN SMALL LETTER K",
        "LATIN SMALL LETTER L",
        "LATIN SMALL LETTER M",
        "LATIN SMALL LETTER N",
        "LATIN SMALL LETTER O",

        # 0x70
        "LATIN SMALL LETTER P",
        "LATIN SMALL LETTER Q",
        "LATIN SMALL LETTER R",
        "LATIN SMALL LETTER S",
        "LATIN SMALL LETTER T",
        "LATIN SMALL LETTER U",
        "LATIN SMALL LETTER V",
        "LATIN SMALL LETTER W",
        "LATIN SMALL LETTER X",
        "LATIN SMALL LETTER Y",
        "LATIN SMALL LETTER Z",
        "LEFT CURLY BRACKET",
        "VERTICAL LINE",
        "RIGHT CURLY BRACKET",
        "TILDE",
        "<control> DEL DELETE"
        );
    ($G0names[126-32] eq "TILDE") || die
        "ord: Internal G0 name table screwed up.\n";
} # setupCharacterNames


###############################################################################
#
sub setupUnixJargon {
    %unixJargon = (
        "!" => "Common: bang; pling; excl; not; shriek; ball-bat. " .
               "Rare: factorial; exclam; smash; cuss; boing; yell; wow; hey; " .
               "wham; eureka; spark-spot; soldier, control",
        "\"" => "Common: double quote; quote. " .
               "Rare: literal mark; double-glitch; snakebite; dirk; " .
               "rabbit-ears; double prime",
        "#" => "Common: number sign; pound; pound sign; hash; " .
               "sharp; crunch; hex; mesh. " .
               "Rare: grid; cross-hatch; octothorpe; flash; pig-pen; " .
               "tic-tac-toe; scratchmark; thud; thump; splat",
        "\$" => "Common: dollar. " .
               "Rare: currency symbol; buck; cash; bling; string (from BASIC); " .
               "escape (when used as the echo of ASCII ESC); ding; cache; big money",
        "%" => "Common: percent; mod; grapes. " .
               "Rare: double-oh-seven",
        "&" => "Common: amp; amper; and, and sign. " .
               "Rare: address (from C); reference (from C++); andpersand; " .
               "bitand; background (from sh(1) ); pretzel",
        "'" => "Common: single quote; quote. " .
               "Rare: prime; glitch; tick; irk; pop; spark;",
        "(" => "Common: l paren; l parenthesis; leftight; open; paren; " .
               "o paren; o parenthesis; l parenthesis; l banana. " .
               "Rare: so; lparen; o round bracket, l round bracket, wax; " .
               "parenthisey; l ear",
        ")" => " Common: r paren; r parenthesis; right; close; the-sis; " .
               "c paren; c parenthesis; r parenthesis; r banana. " .
               "Rare: al-ready; rparen; c round bracket, r round bracket, " .
               "wane; unparenthisey; r ear",
        "*" => "Common: star; splat. " .
               "Rare: wildcard; gear; dingle; mult; spider; aster; " .
               "times; twinkle; glob; Nathan Hale",
        "+" => "Common: add. " .
               "Rare: cross; intersection",
        "," => "" .
               "Rare: tail",
        "-" => "Common: dash. " .
               "Rare: worm; option; dak; bithorpe",
        "." => "Common: dot; point. " .
               "Rare: radix point; full stop; spot",
        "/" => "Common: slash; stroke; forward slash. " .
               "Rare: diagonal; solidus; over; slak; virgule; slat",
        ":" => "Common: . " .
               "Rare: dots; two-spot",
        ";" => "Common: semi. " .
               "Rare: weenie; hybrid, pit-thwong",
        "<" => "Common: bra; l angle; l angle bracket; l broket. " .
               "Rare: from; read from; comes-from; in; crunch; tic; angle",
        ">" => "Common: ket; r angle; r angle bracket; r broket. " .
               "Rare: into, towards; write to; gozinta; out; zap; tac; right angle",
        "=" => "Common: gets; takes. " .
               "Rare: quadrathorpe; half-mesh",
        "?" => "Common: query; ques . " .
               "Rare: quiz; whatmark; what; wildchar; huh; hook; " .
               "buttonhook; hunchback",
        "@" => "Common: at sign; at; strudel. " .
               "Rare: each; vortex; whorl; whirlpool; cyclone; snail; " .
               "ape; cat; rose; cabbage;",
        "V" => "" .
               "Rare: book",
        "[" => "Common: l square bracket; l bracket; bracket. " .
               "Rare: square; U turn",
        "]" => "Common: r square bracket; r bracket; unbracket. " .
               "Rare: un-square; U turn back",
        "\\" => "Common: backslash, hack, whack; escape; reverse slash; " .
               "slosh; backslant; backwhack. " .
               "Rare: bash; reversed virgule; reverse solidus; rsol; backslat",
        "^" => "Common: hat; control; uparrow; caret. " .
               "Rare: xor sign, chevron; shark; shark-fin; to the; " .
               "to the power of; fang; pointer",
        "_" => "Common: underscore; underbar; under. " .
               "Rare: score; backarrow; skid; flatworm",
        "`" => "Common: backquote; left quote; left single quote; " .
               "open quote; grave. " .
               "Rare: backprime; backspark; unapostrophe; birk; blugle; " .
               "back tick; back glitch; push; quasiquote",
        "{" => "Common: o brace; l brace; l squiggly; l squiggly bracket, " .
               "l squiggly brace; l curly bracket, l curly brace. " .
               "Rare: brace; curly-curly; l squirrelly; embrace",
        "}" => "Common: c brace; r brace; r squiggly; r squiggly bracket, " .
               "r squiggly brace; r curly bracket; r curly brace. " .
               "Rare: unbrace; un-curly; r squirrelly; bracelet",
        "|" => "Common: bar; or; or-bar; v-bar; pipe; vertical bar. " .
               "Rare: gozinta; thru; pipesinta; spike",
        "~" => "Common: squiggle; twiddle; not. " .
               "Rare: approx; wiggle; swung dash; enyay"
        );
} # setupUnixJargon


# Also add:
my $foo = [
	# aeox schwa hklmnpst; i=1d62, r=1d63, u=1d64, v=1d65, j=2c7c
    [ 'subscript latin upper (...209c)',	0x02090 ],
    # superscripts: i=2071
    # [ 'subscript latin lower',	    		 ],
    [ 'fullwidth latin upper',			    0x0ff21 ],
    [ 'fullwidth latin lower',			    0x0ff41 ],
];

# See mathUnicode.py for more details.
#
sub setupMathAlphabets {  # Not really all *math*....
    my %mathMissing = (
        0x1d455 => 0x210e,  # ITALIC LOWER H (PLanck Constant)
        0x1d49d => 0x212c,  # SCRIPT UPPER B
        0x1d4a0 => 0x2130,  # SCRIPT UPPER E
        0x1d4a1 => 0x2131,  # SCRIPT UPPER F
        0x1d4a3 => 0x210b,  # SCRIPT UPPER H
        0x1d4a4 => 0x2110,  # SCRIPT UPPER I
        0x1d4a7 => 0x2112,  # SCRIPT UPPER L
        0x1d4a8 => 0x2133,  # SCRIPT UPPER M
        #  => 0x2118 script upper p
        0x1d4ad => 0x211b,  # SCRIPT UPPER R
        0x1d4ba => 0x212f,  # SCRIPT LOWER e
        0x1d4bc => 0x0261,  # SCRIPT LOWER g
        # ??? 0x1d4bc => 0x2113,  # SCRIPT LOWER l
        0x1d4c4 => 0x2134,  # SCRIPT LOWER o
        0x1d506 => 0x212d,  # FRAKTUR UPPER C
        0x1d50b => 0x210c,  # FRAKTUR UPPER H
        0x1d50c => 0x2111,  # FRAKTUR UPPER I
        0x1d50d => 0x1,  # FRAKTUR UPPER J
        0x1d515 => 0x211c,  # FRAKTUR UPPER R
        0x1d51d => 0x2128,  # FRAKTUR UPPER Z
        0x1d53a => 0x2102,  # DOUBLE-STRUCK UPPER C
        0x1d53f => 0x210d,  # DOUBLE-STRUCK UPPER H
        0x1d545 => 0x2115,  # DOUBLE-STRUCK UPPER N
        0x1d547 => 0x2119,  # DOUBLE-STRUCK UPPER P
        0x1d548 => 0x211a,  # DOUBLE-STRUCK UPPER Q
        0x1d549 => 0x211d,  # DOUBLE-STRUCK UPPER R
        0x1d551 => 0x2124,  # DOUBLE-STRUCK UPPER Z
        # 2145-2149 double struck italics
        # 213c-40 double struck pi, gamma, sigma
    );

    $mathAlphabets = [
         [ 'parenthesized LOWER',               'LOWER', 0x0249c ],
         [ 'circled UPPER',  		            'UPPER', 0x024b6 ],
         [ 'circled LOWER',  		            'LOWER', 0x024d0 ],
         [ 'parenthesized UPPER',               'UPPER', 0x1f110 ],
         [ 'squared upper',                     'UPPER', 0x1f130 ],
         [ 'negative circled UPPER',            'UPPER', 0x1f150 ],
         [ 'negative squared UPPER',            'UPPER', 0x1f170 ],
         [ 'regional indicator symbol UPPER',   'UPPER', 0x1f1e6 ],

         # 'mathematical...',
         [ 'M. bold UPPER',                     'UPPER', 0x1d400 ],
         [ 'M. bold LOWER',                     'LOWER', 0x1d41A ],
         [ 'M. italic UPPER',                   'UPPER', 0x1d434 ],
         [ 'M. italic LOWER',                   'LOWER', 0x1d44e ],
         [ 'M. bold italic UPPER',              'UPPER', 0x1d468 ],
         [ 'M. bold italic LOWER',              'LOWER', 0x1d482 ],
         [ 'M. script UPPER',                   'UPPER', 0x1d49C ],
         [ 'M. script LOWER',                   'LOWER', 0x1d4B6 ],
         [ 'M. bold script UPPER',              'UPPER', 0x1d4D0 ],
         [ 'M. bold script LOWER',              'LOWER', 0x1d4EA ],
         [ 'M. fraktur UPPER',                  'UPPER', 0x1d504 ],
         [ 'M. fraktur LOWER',                  'LOWER', 0x1d51E ],
         [ 'M. double-struck UPPER',            'UPPER', 0x1d538 ],
         [ 'M. double-struck LOWER',            'LOWER', 0x1d552 ],
         [ 'M. bold fraktur UPPER',             'UPPER', 0x1d56C ],
         [ 'M. bold fraktur LOWER',             'LOWER', 0x1d586 ],
         [ 'M. sans-serif UPPER',               'UPPER', 0x1d5A0 ],
         [ 'M. sans-serif LOWER',               'LOWER', 0x1d586 ],
         [ 'M. sans-serif bold UPPER',          'UPPER', 0x1d5D4 ],
         [ 'M. sans-serif bold LOWER',          'LOWER', 0x1d5EE ],
         [ 'M. sans-serif italic UPPER',        'UPPER', 0x1d608 ],
         [ 'M. sans-serif italic LOWER',        'LOWER', 0x1d622 ],
         [ 'M. sans-serif bold italic UPPER',   'UPPER', 0x1d63C ],
         [ 'M. sans-serif bold italic LOWER',   'LOWER', 0x1d656 ],
         [ 'M. monospace UPPER',                'UPPER', 0x1d670 ],
         [ 'M. monospace LOWER',                'LOWER', 0x1d68a ],
         # black-letter capital chirz: 0x210c...0x212d = fraktur
         # subscripts: iruv, grk bgrfx 0x1d62...0x1d6a
         #
    ];
    # (couple extras at 1d6a4, dotless i, j)
    # greek upper+lower:
    $mathGreeks = [
        [ 'bold UPPER',                         'UPPER', 0x1d6a8 ],
        [ 'bold LOWER',                         'LOWER', 0x1d6c2 ],
        [ 'italic UPPER',                       'UPPER', 0x1d6e2 ],
        [ 'italic LOWER',                       'LOWER', 0x1d6fc ],
        [ 'bold italic UPPER',                  'UPPER', 0x1d71c ],
        [ 'bold italic LOWER',                  'LOWER', 0x1d736 ],
        [ 'sans serif bold UPPER',              'UPPER', 0x1d756 ],
        [ 'sans serif bold LOWER',              'LOWER', 0x1d770 ],
        [ 'sans serif bold italic UPPER',       'UPPER', 0x1d790 ],
        [ 'sans serif bold italic LOWER',       'LOWER', 0x1d7AA ],
    ];
    $digitSets = [
        # Following go from 0...9 or as indicated
        [ 'bold DIGITS',                        'DIGITS', 0x1d7Ce, 0, 9 ],
        [ 'double struck DIGITS',               'DIGITS', 0x1d7d8, 0, 9 ],
        [ 'sans serif DIGITS',                  'DIGITS', 0x1d7e2, 0, 9 ],
        [ 'sans serif bold DIGITS',             'DIGITS', 0x1d7ec, 0, 9 ],
        [ 'monospace DIGITS',                   'DIGITS', 0x1d7f6, 0, 9 ],
        [ 'subscript latin digits',             'DIGITS', 0x02080, 0, 9 ],
        [ 'fullwidth latin digits',             'DIGITS', 0x0ff11, 0, 9 ],
        [ 'superscript latin digits',           'DIGITS', 0x02070, 0, 0 ],
        [ 'superscript latin digits',           'DIGITS', 0x000b9, 1, 1 ],
        [ 'superscript latin digits',           'DIGITS', 0x000b2, 2, 3 ],
        [ 'superscript latin digits',           'DIGITS', 0x02074, 4, 9 ],

        [ 'circled DIGITS',  		            'DIGITS', 0x024ea, 0,  0 ],
        [ 'circled DIGITS',  		            'DIGITS', 0x02460, 1, 20 ],
        [ 'parenthesized DIGITS',               'DIGITS', 0x02474, 1, 20 ],
        [ 'full stopped DIGITS',                'DIGITS', 0x1f100, 0,  0 ],
        [ 'full stopped DIGITS',                'DIGITS', 0x02488, 1, 20 ],
        [ 'double circled DIGITS',              'DIGITS', 0x024f5, 1, 10 ],
        [ 'dingbat circled sans-serif DIGITS',  'DIGITS', 0x02780, 1, 10 ],
        [ 'dingbat negative circled sans-serif DIGITS','DIGITS',0x0278a,1,10],
        [ 'negative circled DIGITS',            'DIGITS', 0x024ff, 0,  0 ],
        [ 'dingbat negative circled DIGITS',    'DIGITS', 0x02776, 1, 10 ],
        [ 'negative circled DIGITS',            'DIGITS', 0x024eb, 11, 20 ],
        [ 'FULLWIDTH DIGITS',                   'DIGITS', 0x0ff10, 0, 9 ],

        [ 'arabic-indic DIGITS',                'DIGITS', 0x00660, 0, 9 ],
        [ 'extended arabic-indic DIGITS',       'DIGITS', 0x006F0, 0, 9 ],
        [ 'nko DIGITS',                         'DIGITS', 0x007c0, 0, 9 ],
        [ 'devanagari DIGITS',                  'DIGITS', 0x00966, 0, 9 ],
        [ 'bengali DIGITS',                     'DIGITS', 0x009e6, 0, 9 ],
        [ 'gurmukhi DIGITS',                    'DIGITS', 0x00a66, 0, 9 ],
        [ 'gujarati DIGITS',                    'DIGITS', 0x00aE6, 0, 9 ],
        [ 'oriya DIGITS',                       'DIGITS', 0x00b66, 0, 9 ],
        [ 'tamil DIGITS',                       'DIGITS', 0x00bE6, 0, 9 ],
        [ 'telugu DIGITS',                      'DIGITS', 0x00c66, 0, 9 ],
        [ 'kannada DIGITS',                     'DIGITS', 0x00cE6, 0, 9 ],
        [ 'malayalam DIGITS',                   'DIGITS', 0x00d66, 0, 9 ],
        [ 'sinhala lith DIGITS',                'DIGITS', 0x00dE6, 0, 9 ],
        [ 'thai DIGITS',                        'DIGITS', 0x00E50, 0, 9 ],
        [ 'lao DIGITS',                         'DIGITS', 0x00Ed0, 0, 9 ],
        [ 'tibetan DIGITS',                     'DIGITS', 0x00f20, 0, 9 ],
        [ 'MYANMAR DIGITS',                     'DIGITS', 0x01040, 0, 9 ],
        [ 'MYANMAR SHAN DIGITS',                'DIGITS', 0x01090, 0, 9 ],
        [ 'KHMER DIGITS',                       'DIGITS', 0x017e0, 0, 9 ],
        [ 'MONGOLIAN DIGITS',                   'DIGITS', 0x01810, 0, 9 ],
        [ 'LIMBU DIGITS',                       'DIGITS', 0x01946, 0, 9 ],
        [ 'NEW TAI LUE DIGITS',                 'DIGITS', 0x019d0, 0, 9 ],
        [ 'TAI THAM HORA DIGITS',               'DIGITS', 0x01a80, 0, 9 ],
        [ 'TAI THAM THAM DIGITS',               'DIGITS', 0x01a90, 0, 9 ],
        [ 'BALINESE DIGITS',                    'DIGITS', 0x01b50, 0, 9 ],
        [ 'SUNDANESE DIGITS',                   'DIGITS', 0x01bb0, 0, 9 ],
        [ 'LEPCHA DIGITS',                      'DIGITS', 0x01c40, 0, 9 ],
        [ 'OL CHIKI DIGITS',                    'DIGITS', 0x01c50, 0, 9 ],
        [ 'IDEOGRAPHIC NUMBER',                 'DIGITS', 0x03007, 0, 9 ],
        [ 'VAI DIGITS',                         'DIGITS', 0x0a620, 0, 9 ],
        [ 'SAURASHTRA DIGITS',                  'DIGITS', 0x0a8d0, 0, 9 ],
        [ 'COMBINING DEVANAGARI DIGITS',        'DIGITS', 0x0a8e0, 0, 9 ],
        [ 'KAYAH LI DIGITS',                    'DIGITS', 0x0a900, 0, 9 ],
        [ 'JAVANESE DIGITS',                    'DIGITS', 0x0a9d0, 0, 9 ],
        [ 'CHAM DIGITS',                        'DIGITS', 0x0aa50, 0, 9 ],
        [ 'MEETEI MAYEK DIGITS',                'DIGITS', 0x0abf0, 0, 9 ],

        [ 'roman numerals',                     'DIGITS', 0x02160, 1, 12 ],
        [ 'small roman numerals',               'DIGITS', 0x02170, 1, 12 ],
        [ 'playing cards, spades',              'DIGITS', 0x1f0a1, 1, 10 ],
        [ 'playing cards, hearts',              'DIGITS', 0x1f0b1, 1, 10 ],
        [ 'playing cards, diamonds',            'DIGITS', 0x1f0c1, 1, 10 ],
        [ 'playing cards, clubs',               'DIGITS', 0x1f0d1, 1, 10 ],
        [ 'mahjong tiles, characters',          'DIGITS', 0x1f007, 1,  9 ],
        [ 'mahjong tiles, bamboos',             'DIGITS', 0x1f010, 1,  9 ],
        [ 'mahjong tiles, circles',             'DIGITS', 0x1f019, 1,  9 ],
    ];
}

###############################################################################
# See http://www.microsoft.com/typography/unicode/1252.htm
#
sub cp1252ToUnicode {
    my ($char) = @_;
    return($cp1252{$char});
}


###############################################################################
#

=pod

=head1 Usage

ord [options] [chars|mnemonics]

Displays Unicode character code point numbers and other information
about a character(s). For example, "ord BULLET" produces:

    Unicode Name:    BULLET
    Unicode Script:  Common
    Unicode Block:   General Punctuation
    Unicode Plane:   0: Basic Multilingual
    Literal:         •
    Bases:           o20042 d8226 x2022
    Unicode:         U+2022, utf8 \xe2\x80\xa2
    Entities:        &#8226; &#x2022; &bull;
    Nearest ASCII:

You can specify the character(s) to describe in several ways:

=over

=item * via a numeric code point, in octal, decimal, or hex,
e.g. C<012>, C<10>, or C<0xB9>.

=item * For control characters, their short mnemonics such as C<LF>,
or the control-letter equivalent such as C<C-J> or C<^J>.

=item * Full Unicode names like "APL FUNCTIONAL SYMBOL LEFTWARDS VANE",
ignoring case. But if there are spaces in the name, you need to
quote it or use "_" instead of each space.

You can now search for incomplete names using the I<--find>
or I<--regex> option.

=item * A fairly large selection of *nix jargon names (likewise,
quote them if they contain spaces).

=back

Default output includes the character's short name, code point number
(in hexadecimal, decimal, octal, and optional I<--binary>), utf-8 coding in hex,
Unicode long name, Unix Jargon file names for the character,
and the literal character itself.

With I<--find> or I<--regex>, you can retrieve the
code points and names of all matching Unicode characters. For example, to
gather up all the Unicode characters whose formal names include "star", say:
	ord --find star

This may not get all and only stars, much less all characters one might consider
using for the purpose one has in mind -- for example "*" (asterisk) does not have
"star" in its name (not to mention other asterisks, snowflakes, florettes,
and sparkles),
and not all characters with "star" in their name may be desired.

The resulting list can also be written out as sets of declarations for various
languages (see B<--listFormat>).



=head1 Options

(prefix 'no' to option name to negate where applicable)

=over

=item * B<--binary>

Show code points in binary.

=item * B<--chart>

Show a chart of character values and mnemonics.
See also I<--c0>, I<--c1>, I<--g0>, I<--g1>, I<--digits>,
and I<--math> for partial charts.

=item * B<--cp1252>

Assume char set is cp1252.

=item * B<--c0>

Same as I<--chart>, but only for C0 range (d0-d31).

=item * B<--c1>

Same as I<--chart>, but only for C1 range (d128-d159).

=item * B<--decimal>

Display code points in decimal (default).

=item * B<--digits>

Show a chart with of Unicode digits.
Some of these are font/style variations, similar to the alphabets
listable using I<--math>; others are digits from non-Latin writing systems.
See also I<--chart>.

=item * B<--entities>

Display the named HTML special-character entity (if any), and the
SGML/HTML/XML numeric character references (decimal and hexadecimal).

=item * B<--find>

Return all Unicode character names that contain the main argument (this also
happens if nothing is found another way). This is a little slow.

B<Note>: By default this only searches the BMP (code points up to 65535).
To search further, use I<--maxU>

See also I<--listFormat>, I<--regex>, and I<--maxU>.

=item * B<--g0>

Same as I<--chart>, but only for G0 range (d32-d127).

=item * B<--g1>

Same as I<--chart>, but only for G1 range (d160-d255).

=item * B<--hex>

Display code points in hexadecimal (default).

=item * B<--iconv>

For code points >= 128, in addition to the usual display
show the nearest ASCII equivalent, as determined by C<iconv> (q.v.).
Default: off. This requires the Perl Text::Iconv package.

B<Note>: C<iconv>'s mapping may or may not be what you want
in a given situation. For example, accented Latin letters
and Mathematical variants of Latin letters reduce to the plain ASCII letters,
Some characters, such as ligatures and the U+24xx "Control symbols, map
to multiple ASCII characters.

But Greek letters do not map at all, even when they are very closely related
typographically, historically, and phonetically (for example,
upper-case alpha (U+0391) vs. A (U+0041)).
Likewise for non-breaking space (U+A0).

In addition, not all implementations of C<iconv>
work identically (though perhaps Perl versions always use the same one?
Don't know).

=item * B<--jargon>

Display applicable *nix jargon names (default).

=item * B<--listFormat> I<f>

Choose the output layout for results from I<--find> or I<--regex>:

=over

=item * PLAIN (default): The hex code point and the name, tab-separated.

=item * LITERAL:  Like PLAIN, but also showing the actual graphic character.

=item * PERL: Hash entries, from hex code point to name.

=item * PYTHONN: Dict entries, from hex code point to name.

=item * PYTHONC: Dict entries, from unichr(hex code point) to name.

=item * PYTHONS: A Python string constructed from the characters, each
expressed like I<unichr(0xffff)>.

=item * PYTHONU: A Python string constructed from the characters, each
expressed like I<u'\uffff'>.

=item * INFO: A display like the output for single characters.

=item * HTML: HTML table rows with columns for the code point in hex
and the character name.

=back

Of course, for other layouts you can choose the nearest of these and
post-process as desired.

=item * B<--literal>

Include display of the literal character in output (default).
You may wish to turn this off (I<--no-literal>) if your output device
can't handle UTF-8 (you may also wish to get a new output device).

=item * B<--long>

Show long names for characters (default).

=item * B<--math>

Show a display with all the mathematical variants of the Latin
and Greek alphabets. See also I<--chart>.

=item * B<--maxU> I<n>

Only search Unicode characters up through code point I<n> when using
I<--find>, or trying to resolve an unrecognized name. Default: 65535.
Numeric options such as I<--max> can be specified in base 8, 10, or 16.

=item * B<--octal>

Display code points in octal (default).

=item * B<--pairs>

Make a valiant attempt to find symmetric pairs of characters, such as ones
whose names differ only in having "left" vs. "right", "open" vs. "close",
"begin" vs. "end", etc. Write them out as pairs.
Does not do "vertical" pairs, though tweaking the code for that is trivial.

=item * B<--regex>

Like I<--find> (q.v.), but returns any characters whose names match the
given (Perl-style) regex. Implies I<--find>.

=item * B<--short>

Show short names for characters.

=item * B<--typing>

For non-ASCII characters, show how to key it (not yet supported, and of course
system-dependent).

=item * B<--utf8>

Show UTF-8 byte sequence for the character (default).
This will also show the %-escape sequence needed to express the character
in a URI, or "(ok)" if the character is allowed in URIs.
Characters that may be, but are not always, special in URIs
('/%&:;=?@'), are listed by their escapes.

=item * B<--version>

Show version/license info and exit.

=back


=head2 Note

You need to backslash and/or quote some characters to use them as arguments:

    sp  (x20,  d32,  o40)
    \"  (x22,  d34,  o42)
    \#  (x23,  d35,  o43)
    \&  (x26,  d38,  o46)
    \'  (x27,  d39,  o47)
    \(  (x28,  d40,  o50)
    \)  (x29,  d41,  o51)
    \+  (x2b,  d43,  053)
        (or, you can precede this with '--' (end-of-options)
    \;  (x3b,  d59,  o73)
    \<  (x3c,  d60,  o74)
    \>  (x3e,  d62,  o76)
    \\  (x5c,  d92, o134)
    \`  (x60,  d96, o140)
    \|  (x7c, d124, o174)

And some you can't escape in some shells, including:

    \\t (x09,  d09,  o11) HT
    \\n (x0a,  d10,  o12) LF (you can put the newline in double-quotes)
    \\r (x0d,  d13,  o15) CR (you can put the return in double-quotes)



=head1 Known bugs and limitations

Even with a Unicode-enabled terminal such as C<uxterm>, a character > 255
may appear to be length > 1, and so will be taken as a name. But when
the name is not found, we print out the value anyway.

For --pairs, in addition to a list of keywords, the code has a list of character pairs that can be considered symmetric but whose names don't contain the various keywords. But they aren't showing up yet.



=head1 Related commands

C<chr> -- Does the reverse.

C<showNumberInBases> -- Converts a number to multiple bases.

C<mathUnicode.py> -- class to map Latin, Greek, digits to alternate
forms such as Mathematical double-struck, etc.


=head1 Ownership

This work by Steven J. DeRose is licensed under a Creative Commons
Attribution-Share Alike 3.0 Unported License. For further information on
this license, see L<http://creativecommons.org/licenses/by-sa/3.0/>.

For the most recent version, see L<http://www.derose.net/steve/utilities/>.

=cut
