#!/usr/bin/env perl -w
#
# ord: Display information about Unicode characters.
# 2007-10: Written by Steven J. DeRose.
#
use strict;
use Getopt::Long;
use charnames ':full';
use Unicode::UCD 'charscript';
use Unicode::UCD 'charblock';
use Unicode::UCD 'charinfo';
use HTML::Entities;
use Encode;
use URI::Escape;
use POSIX;

#use sjdUtils;  # getUTF8(), isUnicodeCodePoint() are copied locally.

our %metadata = (
    'title'        => "ord",
    'description'  => "Display information about Unicode characters.",
    'rightsHolder' => "Steven J. DeRose",
    'creator'      => "http://viaf.org/viaf/50334488",
    'type'         => "http://purl.org/dc/dcmitype/Software",
    'language'     => "Perl 5.18",
    'created'      => "2007-10",
    'modified'     => "2022-10-10",
    'publisher'    => "http://github.com/sderose",
    'license'      => "https://creativecommons.org/licenses/by-sa/3.0/"
);
our $VERSION_DATE = $metadata{'modified'};

=pod

=encoding utf8


=head1 Usage

ord [options] [chars|mnemonics]

Displays Unicode character code point numbers and other information
about a character(s), or searches the Unicode character database for
particular characters are provides the list of matches in useful formats.

For example, "ord BULLET" produces:

    Unicode Name:    BULLET
    Unicode Script:  Common
    Unicode Block:   General Punctuation
    Unicode Plane:   0: Basic Multilingual
    Literal:         ‚Ä¢
    Bases:           o20042 d08226 x02022
    Unicode:         U+02022, utf8 \xe2\x80\xa2, URI(%e2%80%a2)
    Entities:        &#08226; &#x02022; &bull;

You can specify the character(s) to describe in several ways (to describe
several, separate their specifications by spaces):

=over

=item * ord [char]

A single literal character.

=item * ord [entityName]

An HTML 4 or XML special-character entity name, such as "nbsp".

=item * ord [number]

a numeric code point, in octal, decimal, or hex,
e.g. C<012>, C<10>, or C<0xB9>.
However, a single decimal digit is taken as a request for information on that
ASCII character, not on the (C0 control) character (U+0000-0x0009).
Since all decimal digits are also hex digits, you can
prefix them with "0x" and get the right result.

=item * ord [mnemonic]

For control characters, their short mnemonics such as C<LF>,
or the control-letter equivalent such as C<C-J> or C<^J>.

=item * ord [name]

Full unicode names like "APL FUNCTIONAL SYMBOL LEFTWARDS VANE",
ignoring case. If there are spaces in the name, you need to
quote it or use "_" instead of each space. To use partial names,
see I<--findString> or I<--findRegex>.

=item * ord [jargon]

A fairly large selection of *nix jargon names, such as "splat" or "ket"
(quote them if they contain spaces).

=item * ord [%utfhex]

A literal percent sign followed by a sequence of bytes specified in
hexadecimal, to be interpreted as a UTF-8 character (e.g., '%e280a2'
for U+2022 (Bullet).

=back

To search for all Unicode characters whose names contain a certain
string or regex, that are in a given Unicode block, or that would be matched
by a given regex (say, '\\sLATIN'), use I<--findString>,
I<--findRegex>, B<--findBlock>, or I<--findSet> option.
All I<--find...> matches ignore case.

The list resulting from any of these I<--find...> options can be written out
in many formats, including as a string of the literal characters, a detailed
information display as shown above for single characters,
sets of declarations usable in various programming
languages (see B<--listFormat>), etc. By default, it uses a single line
for each found character, like this:

    U+02022  ‚Ä¢  BULLET

You can limit the search to a certain numeric range with I<--minU> and I<--maxU>.
For example: I<--maxU 0xFFFF> to only search the Base Multilingual Plane.

I<--findString> searches for a literal match within the character's full name.
To gather up Unicode characters whose formal names include "star"
(ignoring case), say:
    ord --findString star

Such a search may not get all and only stars, much less all characters one might
consider using for the purpose one has in mind -- for example:

    "*" (asterisk) does not have "star" in its name
    Nor do many other asterisks, snowflakes, florettes, and sparkles.
    Some character have "star" in their name but may not be wanted:
        U+00001     START OF HEADING
        U+00f0c ‡ºå   TIBETAN MARK DELIMITER TSHEG BSTAR
        U+029e6 ‚ß¶   GLEICH STARK
        U+1f303 üåÉ  NIGHT WITH STARS
        U+1f752 üùí  ALCHEMICAL SYMBOL FOR STARRED TRIDENT

I<--findRegex> searches via regex within the character's full name.

I<--findBlock> searches for characters whose Unicode block name, such as
"General Punctuation", matches the specified regex. Also prints a heading
at the start of each matching block.

I<--findSet> searches for characters which, as literals, match the specified
regex. For example, to find what characters are included by (Perl's)
regex '\\s' shorthand, use:
    ord --findSet "\\s"

I<--pairs> is a special "find", that searches for symmetric pairs of characters,
such as brackets, quotes, etc, and writes them out as HTML similar
to I<--listFormat HTML>.

If you specify more than one of the I<--findXXX> options, the result is
not defined.


=head1 Options

(prefix 'no' to option name to negate where applicable)

=over

=item * B<--binary>

Show code points in binary.

=item * B<--chart> I<name>

Show info for all the characters in a named range chosen from:
c0, g0, c1, g1, ASCII, Latin1, LatinxA (for Latin Extended A), LatinxB,
IPA, Combining, Greek, Cyrillic, Armenian, Hebrew, Arabic, Syriac,
ControlPic (symbols for control characters).
Ask if you want others, or just add an entry to '%namedRanges'.

The range can also be given as two (decimal or hex) integers,
separated by non-word characters (such as  '-', ':', '...', ', ', etc.).
See also I<--c0>, I<--c1>, I<--g0>, I<--g1>
(which are just synonyms for I<--chart> with the corresponding value).
See also I<--table>, I<--digits>, and I<--math> for other kinds of charts.
Charts are not affected by I<--minU> or I<maxU>.

=item * B<--cp1252>

Assume the input character set is Windows(r) code page I<cp1252>.

=item * B<--c0>

Same as I<--chart>, but only for C0 range (d0-d31).

=item * B<--c1>

Same as I<--chart>, but only for C1 range (d128-d159).

=item * B<--decimal>

Display code points in decimal (default).

=item * B<--digits>

Show a chart of Unicode digits.
Some of these are font/style variations, similar to the "MATHEMATICAL" alphabets
listable using I<--math>; others are digits from non-Latin writing systems.
See also I<--chart>.

=item * B<--entities>

Display the named HTML special-character entity (if any), and the
SGML/HTML/XML numeric character references (decimal and hexadecimal).

=item * B<--findBlock>

Like I<--findString> (q.v.), but treats the main/final argument as the name
of a Unicode ''block'' (ignoring case), and returns all
characters assigned to the block(s) that match
(and in the code point range from I<--min> and I<--max>).

=item * B<--findRegex> or B<--regex>

Like I<--findString> (q.v.), but treats the final
argument as a (Perl-style) regex, and returns any
characters whose names match the given (ignoring case).

=item * B<--findSet> searches for characters which, as literals,
match the specified regex.
For example, to find what characters are included by (Perl's)
regex '\\s' shorthand, use:
    ord --findSet "\\s"

=item * B<--findString> or just I<-f>

Return all Unicode character names that contain the main argument (this also
happens if nothing is found another way). This is a little slow.

B<Note>: By default this only searches the first two Unicode
planes(code points up to 0x1FFFF).
To search further or less far, use  I<--minU> and/or I<--maxU>.

See also I<--listFormat>, I<--findRegex>, I<--findBlock>, and I<--maxU>.

=item * B<--g0>

Same as I<--chart>, but only for G0 range (d32-d127).

=item * B<--g1>

Same as I<--chart>, but only for G1 range (d160-d255).

=item * B<--hex>

Display code points in hexadecimal (default).

=item * B<--iconv>

For code points >= 128, in addition to the usual display
show the nearest ASCII equivalent, as determined by C<iconv> (q.v.).
Default: off. This requires the Perl Text::Iconv package.

B<Note>: C<iconv>'s mapping may or may not be what you want
in a given situation. For example, accented Latin letters
and Mathematical variants of Latin letters reduce to the plain ASCII letters,
Some characters, such as ligatures and the U+24xx "Control pictures", map
to multiple ASCII characters.
But Greek letters do not map at all, even when they are very closely related
typographically, historically, and phonetically (for example,
upper-case alpha (U+0391) vs. A (U+0041)).
Likewise for non-breaking space (U+A0).

In addition, not all implementations of C<iconv>
work identically (though perhaps Perl versions always use the same one?
Don't know).

=item * B<--jargon>

Display applicable *nix jargon names (default).

=item * B<--listFormat> I<f> OR B<--outFormat> OR B<--oFormat>

Choose the output layout for results from the several I<--find...> options:

=over

=item * PLAIN (default): The hex code point and the name, tab-separated:

    U+002a  ASTERISK
    U+0359  COMBINING ASTERISK BELOW
    U+204e  LOW ASTERISK

=item * LITERAL: Like PLAIN, but also showing the actual graphic character.

    U+002a  *   ASTERISK
    U+0359  Õô   COMBINING ASTERISK BELOW
    U+204e  ‚Åé   LOW ASTERISK

=item * STRING: A string of just the selected literal characters.
    u"* Õô‚Åé"

=item * REGEX: A regular expression "[..]" construct, that matches just 
the selected literal characters.  At least as of now, non-ASCII
characters, hyphen, caret, or rsqb, and C0 controls are expressed via 
backslashed hex codes. Runs of contiguous code points should be, but are not yet,
coalesced into ranges.
    u"[*.\u204e]"

=item * PERL: Hash entries, from hex code point to name.

    0x0002a => 'ASTERISK',
    0x00359 => 'COMBINING ASTERISK BELOW',
    0x0204e => 'LOW ASTERISK',

=item * PYTHONN: Dict entries, from hex code point to name, like:

    0x0002a: 'ASTERISK',
    0x00359: 'COMBINING ASTERISK BELOW',
    0x0204e: 'LOW ASTERISK',

=item * PYTHONC: Dict entries, from unichr(hex code point) to name.

    chr(0x0002a): 'ASTERISK',
    chr(0x00359): 'COMBINING ASTERISK BELOW',
    chr(0x0204e): 'LOW ASTERISK',

=item * PYTHONS: A Python string constructed from the characters, each
expressed like I<chr(0x0ffff)>:

    chr(0x0002a) +  # 'ASTERISK'
    chr(0x00359) +  # 'COMBINING ASTERISK BELOW'
    chr(0x0204e) +  # 'LOW ASTERISK'

=item * PYTHONU: A Python string constructed from the characters, each
expressed like I<u'\uffff'>.

    u'\u0002a' +  # 'ASTERISK'
    u'\u00359' +  # 'COMBINING ASTERISK BELOW'
    u'\u0204e' +  # 'LOW ASTERISK'

=item * INFO: A display like the output for single characters.

=item * HTML: HTML table rows with columns for the actual character,
the code point in hex, and the character name:

    <tr>
        <td class='char'>&#x002a;</td>
        <td class='hex'>U+002a</td>
        <td class='name'>ASTERISK</td>
    </tr>

For the ''PYTHON'' variants, you can use ''--pyFunction'' to set what
function is used (for example, ''--pyfunction chr''.

=back

Of course, for other layouts you can choose the nearest of these and
post-process as desired.

=item * B<--literal>

Include display of the literal character in output (default).
You may wish to turn this off (I<--no-literal>) if your output device
can't handle UTF-8 (you may also wish to get a new output device).

=item * B<--long>

Show long names for characters (default).

=item * B<--math>

Show a display with all the mathematical variants of the Latin
and Greek alphabets. See also I<--chart>, and the
C<mathAlphanumerics> package.

=item * B<--maxU> I<n>

Only search Unicode characters up through code point I<n> when using
any of the several I<--find...> options,
or trying to resolve an unrecognized name. Default: 65535 (0xoFFFF).
Numeric options such as I<--max> can be specified in base 8, 10, or 16.

=item * B<--minU> I<n>

Only search Unicode characters starting from code point I<n> when using
any of the several I<--find...> options,
or trying to resolve an unrecognized name. Default: 65535 (0xoFFFF).
Numeric options such as I<--max> can be specified in base 8, 10, or 16.

=item * B<--octal>

Display code points in octal (default).

=item * B<--pairs>

Make a valiant attempt to find symmetric pairs of characters, such as ones
whose names differ only in having "left" vs. "right", "open" vs. "close",
"begin" vs. "end", etc. Write them out as pairs.
Does not do "vertical" pairs.

=item * B<--regex>

Synonym for I<--findRegex>.

=item * B<--short>

Show short names for characters.

=item * B<--table> I<name>

Show a compact table of characters in the named range
(c0, g0, c1, g1, ascii, or latin1).
See also I<--c0>, I<--c1>, I<--g0>, I<--g1>, I<--table>, I<--digits>,
and I<--math> for other kinds of displays.
See also I<--chart> for a different layout.

=item * B<--typing>

For non-ASCII characters, show how to key it (not yet supported, and of course
system-dependent).

=item * B<--utf8>

Show a variety of information about the UTF-8 encoding for the character(s).
Default: on.
B<Note>: To interpret hex input as UTF-8 instead of a codepoint, prefix
it with "%" instead of "0x" (see above). You do not need to specify
the I<--utf8> option for that.

=item * B<--version>

Show version/license info and exit.

=back

=head2 Note

You need to backslash and/or quote some characters to use them as arguments:

    sp  (x20,  d32,  o40)
    \"  (x22,  d34,  o42)
    \#  (x23,  d35,  o43)
    \&  (x26,  d38,  o46)
    \'  (x27,  d39,  o47)
    \(  (x28,  d40,  o50)
    \)  (x29,  d41,  o51)
    \+  (x2b,  d43,  053)
        (or, you can precede this with '--' (end-of-options)
    \;  (x3b,  d59,  o73)
    \<  (x3c,  d60,  o74)
    \>  (x3e,  d62,  o76)
    \\  (x5c,  d92, o134)
    \`  (x60,  d96, o140)
    \|  (x7c, d124, o174)

And some you can't escape in some shells, including:

    \\t (x09,  d09,  o11) HT
    \\n (x0a,  d10,  o12) LF (you can put the newline in double-quotes)
    \\r (x0d,  d13,  o15) CR (you can put the return in double-quotes)


=head1 Known bugs and limitations

Even with a Unicode-enabled terminal, a character > 255
may appear to be length > 1 and so will be taken as a name. But when
the name is not found, we print out the value anyway.

For C<--pairs>, in addition to a list of keywords the code has a list of character
pairs that can be considered symmetric but whose names don't contain the various
keywords. But they aren't showing up yet.

Reports look a little weird in the case of combining characters. Especially if
you search for just the combining characters, and print them out as
I<--listFormat STRING>.

Reports code points in the private use areas as "Not a Unicode code point".
A more specific message would be better.


=head1 Related commands

C<chr> -- Does the reverse.

C<showNumberInBases> -- Converts a number to multiple bases.

C<mathAlphanumerics.py> -- class to map Latin, Greek, digits to alternate
forms such as Mathematical double-struck, etc.


=head1 To do

=over

=item * Tweak --table to accept numeric range like --chart.

=item * Port to Python, using my C<CharDisplay.py> package.

=item * Make `--listFormat` apply to the main list, not just `-f`.

=item * Extend --listformat REGEX to coalesce contiguous ranges.

=item * Integrate remainder of C<chr> command functionality:
Allow numbers on command line. Compare/sync report format.

=item * Way to print/export remaining Unicode char properties.

=item * Add I<--typing> show how to key on various systems?

=item * Make I<find> on names match regardless of token order. Cf
Joel Kalvesmaki, '''A New \\u: Extending XSLT
Regular Expressions for Unicode.''' Balisage (2020).
[https://www.balisage.net/Proceedings/vol25/html/Kalvesmaki01/BalisageVol25-Kalvesmaki01.html]

=back


=head1 History

=over

=item * 2007-11-22 sjd:  Accept control-char mnemonics as input. Getopt.
Add binary and long-name output.

=item * 2008-02-14 sjd: Multiple input chars. setupCharacterNames(). Unify $fmt.
Add longNames for G0 and G1. Add C<--g0>, C<--g1>. C<perl -w>.

=item * 2008-09-03 sjd: Move to BSD. Improve doc.

=item * 2008-09-16 sjd: Better handling of Unicode input.

=item * 2010-01-06 sjd: Use 'charnames' to know Unicode names. Add C<--binary>.
Make print utf-8 and actual Unicode character. Format binary better.

=item * 2010-05-03 sjd: perldoc. Unify formatting. Add Unix Jargon names,
rest of short names. Make user use "_" in.

=item * 2011-08-23 sjd: Add options to control each display form separately.
Start C<--cp1252>.

=item * 2011-12-11 sjd: Add utf-8 output. Opt out of longNames (lists of
char names -- now using viacode instead).

=item * 2012-01-10 sjd: Cleanup. Lose internal 'longNames' lists.

=item * 2012-08-15 sjd: sjdUtils, and use getUTF8().

=item * 2013-06-17ff sjd: Add C<--entities>, esp. HTML named ones.
Add showUnicodeInfo().

=item * 2014-09-02: Clean up.

=item * 2015-08-15ff: Add formats PYTHONS, PYTHONU; rename
format PYTHON to PYTHONN. Finish C<--find>. Display control-char mnemonics.

=item * 2016-01-08: Add C<--math> and C<--digits>.

=item * 2016-02-18: Add C<--regex>, C<--listFormat> CHART and HTML.
Warn if env LANG not utf-8. Recognize html entity names, C-J, ^J, etc.

=item * 2016-08-30: Get rid of sjdUtils.pm dependencies.

=item * 2016-09-05: Add C<--iconv> option.

=item * 2018-01-19: Add C<--pairs>.

=item * 2020-01-03: Add C<--minU>.

=item * 2020-03-17: Factor out all the %05x formatting. Add I<--findSet>.

=item * 2020-09-03: Clean up. Add warning for I<--findString> w/ bad chars.

=item * 2020-11-30: Support hex UTF-8 input.

=item * 2021-07-24: Add character categories.

=item * 2021-08-05: Add --table, re-do --chart.

=item * 2021-09-13: Clean up --chart, make it allow explicit int...int ranges,
ignore case for name lookups, have more named ranges.

=item * 2022-07-25: Fix off-by-one on reporting control-key letters for C0.

=item * 2022-10-10: Add names for Unicode categories, from CharDisplay.py.

=item * 2023-02-08: Add REGEX as output format option, though it doesn't yet
coalesce contiguous ranges.
=back


=head1 Rights

Copyright 2007-11-22 by Steven J. DeRose. This work is licensed under a
Creative Commons Attribution-Share Alike 3.0 Unported License.
For further information on this license, see
L<https://creativecommons.org/licenses/by-sa/3.0>.

For the most recent version, see L<http://www.derose.net/steve/utilities> or
L<https://github.com/sderose>.


=cut


###############################################################################
#
my @C0names     = ();
my @G0names     = ();
my @C1names     = ();
my @G1names     = ();

my $upper        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
my $lower        = 'abcdefghijklmnopqrstuvwxyz';
my $URIchars     = "!\$'()*+-._" . '0123456789' . $upper . $lower;
my $URIspecials  = '/%&:;=?@';

# sprintf() formats for code point numbers. TODO: Make adjustable width
#
my $theHexFormat = "0x%05x";
my $theUFormat   = "U+%05x";
my $theEntFormat = "&#x%05x;";
my $thePyFormat  = "u'\\u%05x'";

my %unixJargon   = ();

my %unicodeCategories = (
    "C" =>  "Other (all subtypes)",
    "L" =>  "Letter (all subtypes)",
    "M" =>  "Mark (all subtypes)",
    "N" =>  "Number (all subtypes)",
    "P" =>  "Punctuation (all subtypes)",
    "S" =>  "Symbol (all subtypes)",
    "Z" =>  "Separator (all subtypes)",

    "Cc" => "Other, Control",
    "Cf" => "Other, Format",
    "Cn" => "Other, Not Assigned",
    "Co" => "Other, Private Use",
    "Cs" => "Other, Surrogate",
    "LC" => "Letter, Cased",
    "Ll" => "Letter, Lowercase",
    "Lm" => "Letter, Modifier",
    "Lo" => "Letter, Other",
    "Lt" => "Letter, Titlecase",
    "Lu" => "Letter, Uppercase",
    "Mc" => "Mark, Spacing Combining",
    "Me" => "Mark, Enclosing",
    "Mn" => "Mark, Nonspacing",
    "Nd" => "Number, Decimal Digit",
    "Nl" => "Number, Letter",
    "No" => "Number, Other",
    "Pc" => "Punctuation, Connector",
    "Pd" => "Punctuation, Dash",
    "Pe" => "Punctuation, Close",
    "Pf" => "Punctuation, Final quote",
    "Pi" => "Punctuation, Initial quote",
    "Po" => "Punctuation, Other",
    "Ps" => "Punctuation, Open",
    "Sc" => "Symbol, Currency",
    "Sk" => "Symbol, Modifier",
    "Sm" => "Symbol, Math",
    "So" => "Symbol, Other",
    "Zl" => "Separator, Line",
    "Zp" => "Separator, Paragraph",
    "Zs" => "Separator, Space",
);

setupShortCharacterNames();
setupUnixJargon();
my ($mathAlphabets, $mathGreeks, $digitSets, %mathMissing);
setupMathAlphabets();


###############################################################################
# Options
#
my $binary      = 0;
my $chart       = "";
my $cp1252      = 0;
my $decimal     = 1;
my $digits      = 0;
my $entities    = 1;
my $findBlock   = 0;
my $findRegex   = 0;
my $findSet     = 0;
my $findString  = 0;
my $C0          = 0;
my $C1          = 0;
my $G0          = 0;
my $G1          = 0;
my $hex         = 1;
my $iconv       = 0;
my $jargon      = 1;
my $listFormat  = "LITERAL";
my $literal     = 1;
my $long        = 1;
my $math        = 0;
my $maxU        = 0x1FFFF;
my $minU        = 1;
my $octal       = 1;
my $pairs       = 0;
my $pyFunction  = 'chr';
my $quiet       = 0;
my $short       = 0;
my $typing      = 1;
my $table       = "";
my $utf8        = 1;
my $verbose     = 0;

Getopt::Long::Configure ("ignore_case");
my $result = GetOptions(
    "binary!"             => \$binary,
    "c|chart=s"           => \$chart,
    "cp1252!"             => \$cp1252,
    "c0"                  => \$C0,
    "c1"                  => \$C1,
    "decimal!"            => \$decimal,
    "digits!"             => \$digits,
    "entities!"           => \$entities,
    "findBlock!"          => \$findBlock,
    "findRegex|regex!"    => \$findRegex,
    "findSet!"            => \$findSet,
    "f|findString!"       => \$findString,
    "g0"                  => \$G0,
    "g1"                  => \$G1,
    "h|help|?"            => sub { system "perldoc $0"; },
    "hex!"                => \$hex,
    "iconv!"              => \$iconv,
    "jargon!"             => \$jargon,
    "listFormat|outFormat|oFormat=s" => \$listFormat,
    "literal!"            => \$literal,
    "long!"               => \$long,
    "math!"               => \$math,
    "maxU=o"              => \$maxU,
    "minU=o"              => \$minU,
    "octal!"              => \$octal,
    "pairs!"              => \$pairs,
    "pyFunction=s"        => \$pyFunction,
    "q|quiet!"            => \$quiet,
    "short!"              => \$short,
    "table=s"             => \$table,
    "typing!"             => \$typing,
    "utf8!"               => \$utf8,
    "v|verbose+"          => \$verbose,
    "version"             => sub {
        warn "Version of $VERSION_DATE, by Steven J. DeRose.\n";
        exit;
    },
);
($result) || die "Bad options.\n";

if (!$quiet && $findString && $ARGV[0] =~ m/[^A-Za-z 0-9]/) {
    # ()., also occur in my Charsets/Unicode/metaUnicode/NamesList.txt, but
    # I think they're only from synonym / alt name entries?
    warn "\nWARNING: --findString for '" . $ARGV[0] .
        "' has characters not used in Unicode names. Use --findRegex?\n";
}

my $iconvConverter = undef;
if ($iconv) {
    (sjdUtils::try_module("Text::Iconv")) || die
        "CPAN module TextIconv not found. Install it if you want --iconv.\n";
    $iconvConverter = Text::Iconv->new("utf8", "ascii//TRANSLIT");
}
$listFormat = uc($listFormat);
my %listFormats = (
    "HTML"      => 1,
    "INFO"      => 1,
    "LITERAL"   => 1,
    "PERL"      => 1,
    "PLAIN"     => 1,
    "PYTHONN"   => 1,
    "PYTHONS"   => 1,
    "PYTHONU"   => 1,
    "PYTHONC"   => 1,
    "STRING"    => 1,
    "REGEX"     => 1,
    );
(defined $listFormats{$listFormat}) || die
    "Unknown --listFormat '$listFormat'. Known: "
    . join(", ", sort keys %listFormats) . "\n";

($minU < $maxU) || die
    "--minU ($minU)must be less than --maxU ($maxU).\n";


###############################################################################
#
sub showDigits {
    my $prevName = "";
    for (my $i=0; $i<scalar(@{$digitSets}); $i++) {
        my $foo = $digitSets->[$i];
        my $cpA = $foo->[2];
        my $name = $foo->[0];
        printf("******* %s (%s...):\n", uc($name), uDisp($cpA));
        my $msg = "";
        my $howMany = $foo->[4] - $foo->[3] + 1;
        if ($foo->[3] > 0) { $msg .= "   " x $foo->[3]; }
        for (my $n=0; $n<$howMany; $n++) {
            $msg .= sprintf("%3s", chr($cpA+$n));
        }
        print($msg . "\n");
        $prevName = $name;
    }
}

sub showMathAlphabets {
    print("\nLatin:\n");
    for (my $i=0; $i<scalar(@{$mathAlphabets}); $i++) {
        my $foo = $mathAlphabets->[$i];
        my $cpA = $foo->[2];
        printf("******* %s (%s...):\n", uc($foo->[0]), uDisp($cpA));
        my $msg = my $extra = "";
        for (my $cp=$cpA; $cp<$cpA+26; $cp++) {
            if ($mathMissing{$cp}) {
                $msg .= '  -';
                $extra .= sprintf("%s is %s, ",
                    chr($mathMissing{$cp}), uDisp($mathMissing{$cp}));
            }
            else { $msg .= sprintf("%3s", chr($cp)); }
        }
        print($msg . "\n");
        if ($extra) { print("    Also: $extra.\n"); }
    }
    print("\nGreek:\n");
    for (my $i=0; $i<scalar(@{$mathGreeks}); $i++) {
        my $foo = $mathGreeks->[$i];
        my $cpA = $foo->[2];
        printf("******* %s (%s...):\n", uc($foo->[0]), uDisp($cpA));
        my $msg = "";
        for (my $cp=$cpA; $cp<$cpA+25; $cp++) {
            $msg .= sprintf("%3s", chr($cp));
        }
        print($msg . "\n");
    }
}

###############################################################################
#
# Try to locate characters that come in symmetric pairs, such as:
#     left/right  up/down  open/close  increment/decrement? contains/contained
# Not trying:
#     intersection/union  all/exists, lt/gt,
#
sub searchForSymmetricPairs {
    print(qq@<html>
<head>
<style type="text/css">
    td.char { text-align:center; font-size:larger; }
</style>
</head>
<body>
<h1>Table of Unicode symmetric pairs (approximate)</h1>
<p>(generated by <i>ord</i>, by Steven J. DeRose)</p>

<table border="border">
@);
    # List cases we know we don't catch...
    my %otherPairs = (
        # Dingbats
        0x275B => 0x275C,  # squo ornament
        0x275D => 0x275E,  # dquo ornament
        0x275F => 0x2760,  # low comma ornament
        0x27C8 => 0x27C9,  # rsol subset / superset sol
        0x27D3 => 0x27D4,  # lower right / upper left corner (box drawing?)
        # Dominos and mah jong tiles? Braille patterns?
        # Emoticons? smile/frown
        # Alchemical aqua fortis vs. regis?
        # Punctuation (prime vs. reversed)
        0x2032 => 0x2035,
        0x2033 => 0x2036,
        0x2034 => 0x2037,
        # 2057 => ???
        # Logical/math inversion
        0x2200 => 0x2203,
        0x2206 => 0x2206,
        0x2208 => 0x2209,
        0x220A => 0x220D,
        0x220B => 0x220C,
        0x22B2 => 0x22B3,
        0x22B4 => 0x22B5,
        # Controls
        0x0001 => 0x0003,
        0x0002 => 0x0002,
        0x0005 => 0x0006,
        0x000E => 0x000F,
        0x2401 => 0x2403,
        0x2402 => 0x2402,
        0x2405 => 0x2406,
        0x240E => 0x240F,
        0x10140 => 0x10141,
    );
    if ($verbose) {
        while ((my $key, my $value) = each (%otherPairs)) {
            warn sprintf("$theHexFormat: $theHexFormat\n", $key, $value);
        }
    }

    # Could do "-" special, but want to avoid "OPEN-HEADED ARROW", etc.

    my @leftWords = (
        'LEFT', 'LEFTWARDS', 'LEFT-POINTING', 'LEFT-FACING',
        'RIGHT-TO-LEFT', 'LEFT-HANDED', 'LEFT-SIDE',
        'OPEN', 'BEGIN', 'START',
        'LESS-THAN', 'PRECEDES', 'SUBSET', 'IMAGE', 'ELEMENT OF');
    my @rightWords = (
        'RIGHT', 'RIGHTWARDS', , 'RIGHT-POINTING', 'RIGHT-FACING',
        'LEFT-TO-RIGHT', 'RIGHT-HANDED', 'RIGHT-SIDE',
        'CLOSE', 'END', 'END',
        'GREATER-THAN', 'SUCCEEDS', 'SUPERSET', 'ORIGINAL', 'CONTAINS');

    my @upWords = (
        'UP', 'UPWARDS', 'UP-POINTING', 'UP-FACING',
        'DOWN-TO-UP', 'RISING',
        );
    my @downWords = (
        'DOWN', 'DOWNWARDS', 'DOWN-POINTING', 'DOWN-FACING',
        'UP-TO-DOWN', 'FALLING',
        );

    my $allExpr  = join("|", @leftWords) .'|' .  join("|", @rightWords);
    my $leftExpr = join("|", @leftWords);
    my $rightExpr = join("|", @rightWords);
    if (scalar(@leftWords) != scalar(@rightWords)) {
        die "Token count mismatch:\n$leftExpr\n$rightExpr\n";
    }

    my %pairMap = ();
    for (my $i=0; $i<scalar(@leftWords); $i++) {
        $pairMap{$leftWords[$i]} = $rightWords[$i];
        0 && warn sprintf("pairing '%s' => '%s'\n",
            $leftWords[$i], $pairMap{$leftWords[$i]});
    }
    my %lame = ( 0x0FD5=>1, 0x0FD6=>1, 0x0FD7=>1, 0x0FD8=>1 );

    my $nCandidates = 0;
    my @candidates = ();
    my %candidateIndex = ();
    for (my $i=$minU; $i<=$maxU; $i++) {
        if (exists $lame{$i}) { next; }
        if (!$quiet && ($i % 0x10000)==0) {
            warn sprintf("...starting Unicode plane at %s...\n", hexDisp($i));
        }
        my $iname = charnames::viacode($i);
        if (!$iname) {
            # sprintf("Cannot get name for %s.\n", uDisp($i));
            next;
        }
        # This isn't working...
        my $isOther = exists $otherPairs{$i};
        #($isOther) && warn "Got a special case: $i\n";
        if ($isOther || ($iname =~ m/\b($allExpr)\b/)) {
            if (!$iname) { warn "Not found\n"; }
            push(@candidates, [$i, $iname]);
            $candidateIndex{$iname} = $i;
            $nCandidates++;
        }
    }
    for (my $i=0; $i<$nCandidates; $i++) {
        my $lNum  = $candidates[$i][0];
        my $lName = $candidates[$i][1];
        ($lName) || die sprintf("*** item %d (of %d vs %d) has no name???\n",
                $i, $nCandidates, scalar(@candidates));
        if ($lName !~ m/\b($leftExpr)\b/) { next; }
        my $rName = $lName;
        $rName =~ s/\b($leftExpr)\b/{
            (exists $pairMap{$1}) || die "Missing left: ".$pairMap{$1}.".\n";
            $pairMap{$1}
        }/e;
        if (!exists $candidateIndex{$rName}) { next; }
        my $rNum = $candidateIndex{$rName};
        my $rec = "<tr>\n"
        . sprintf("    <td class='char'>%s</td>\n", entDisp($lNum))
        . sprintf("    <td class='char'>%s</td>\n", entDisp($rNum))
        . sprintf("    <td class='hex'>%s</td>\n", uDisp($lNum))
        . sprintf("    <td class='hex'>%s</td>\n", uDisp($rNum))
        . sprintf("    <td class='names'>%s\n                 <br \>%s</td>\n",
            $lName, $rName)
        . "</tr>\n";
        print $rec;
    }
    my $msg = sprintf(
        "%d character pairs found from %s to %s (see --maxU).",
        $nCandidates, uDisp($minU), uDisp($maxU));
    if ($nCandidates<1 && $maxU < 0x10000) {
        $msg .= " Trying raising --maxU to 0x1FFFF?";
    }

    print("</table>\n</body>\n</html>\n");
    exit;
} # searchForSymmetricPairs


###############################################################################
# (Data also available in tupleSets/cp1252.xsv, and in 'chr')
#
my %cp1252 = (
    # CP1252 => Unicode
    0x000080 => 0x20AC,   # EURO SIGN
    0x000082 => 0x201A,   # SINGLE LOW-9 QUOTATION MARK
    0x000083 => 0x0192,   # LATIN SMALL LETTER F WITH HOOK
    0x000084 => 0x201E,   # DOUBLE LOW-9 QUOTATION MARK
    0x000085 => 0x2026,   # HORIZONTAL ELLIPSIS
    0x000086 => 0x2020,   # DAGGER
    0x000087 => 0x2021,   # DOUBLE DAGGER
    0x000088 => 0x02C6,   # MODIFIER LETTER CIRCUMFLEX ACCENT
    0x000089 => 0x2030,   # PER MILLE SIGN
    0x00008A => 0x0160,   # LATIN CAPITAL LETTER S WITH CARON
    0x00008B => 0x2039,   # SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    0x00008C => 0x0152,   # LATIN CAPITAL LIGATURE OE
    0x00008E => 0x017D,   # LATIN CAPITAL LETTER Z WITH CARON
    0x000091 => 0x2018,   # LEFT SINGLE QUOTATION MARK
    0x000092 => 0x2019,   # RIGHT SINGLE QUOTATION MARK
    0x000093 => 0x201C,   # LEFT DOUBLE QUOTATION MARK
    0x000094 => 0x201D,   # RIGHT DOUBLE QUOTATION MARK
    0x000095 => 0x2022,   # BULLET
    0x000096 => 0x2013,   # EN DASH
    0x000097 => 0x2014,   # EM DASH
    0x000098 => 0x02DC,   # SMALL TILDE
    0x000099 => 0x2122,   # TRADE MARK SIGN
    0x00009A => 0x0161,   # LATIN SMALL LETTER S WITH CARON
    0x00009B => 0x203A,   # SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    0x00009C => 0x0153,   # LATIN SMALL LIGATURE OE
    0x00009E => 0x017E,   # LATIN SMALL LETTER Z WITH CARON
    0x00009F => 0x0178,   # LATIN CAPITAL LETTER Y WITH DIAERESIS
    );

# Return the UTF-8 byte sequences for a given character code,
# punctuated as needed to put in a URI.
#
sub getUTF8local {
    my ($n, $sep) = @_;
    if (!defined $sep) { $sep = "%"; }
    my $utf8form= Encode::encode('utf8', chr($n));
    my $ux = ();
    for (my $i=0; $i<length($utf8form); $i++) {
        $ux .= sprintf("%s%02x", $sep, ord(substr($utf8form,$i,1)));
    }
    return($ux);
}

sub isUnicodeCodePoint {
    my ($n) = @_;
    if ($n  < 0x000000 || $n  > 0x10FFFF
        ||  $n == 0x00E000 || $n == 0x00F8FF
       #|| ($n >= 0x00FFFE && $n <= 0x00FFFF)     # Private use area
       #|| ($n >= 0x0F0000 && $n <= 0x0FFFFD))    # Private use A
       #|| ($n >= 0x100000 && $n <= 0x10FFFD)     # Private use B
       #|| ($n >= 0x000080 && $n <= 0x00009F)     # C1 control chars
        || ($n >= 0x002060 && $n <= 0x002069)     # reserved format and control
        || ($n >= 0x0E0000 && $n <= 0x0E1000)     # reserved format and control
        ) { return(0); }
    if (!charnames::viacode($n)) { return(0); }   # Perl can't find a name
    return(1);
}

sub hexDisp {
    my ($n) = @_;
    return sprintf($theHexFormat, $n);
}
sub uDisp {
    my ($n) = @_;
    return sprintf($theUFormat, $n);
}
sub entDisp {
    my ($n) = @_;
    return sprintf($theEntFormat, $n);
}
sub pyDisp {
    my ($n) = @_;
    return sprintf($thePyFormat, $n);
}


###############################################################################
# Display info for all the characters in a given range.
#
my %namedRanges = (  # Do lookups in all lower case.
    "c0"          => [ 0x0000, 0x001f ],
    "g0"          => [ 0x0020, 0x007f ],
    "c1"          => [ 0x0080, 0x009f ],
    "g1"          => [ 0x00a0, 0x00ff ],
    "ascii"       => [ 0x0000, 0x007f ],
    "latin1"      => [ 0x0000, 0x00ff ],
    "latinxa"     => [ 0x0100, 0x017f ],
    "latinxb"     => [ 0x0180, 0x024f ],
    "ipa"         => [ 0x0250, 0x02af ],
    "combining"   => [ 0x0300, 0x036f ],
    "greek"       => [ 0x0370, 0x03ff ],
    "cyrillic"    => [ 0x0400, 0x04ff ],
    "armenian"    => [ 0x0530, 0x058f ],
    "hebrew"      => [ 0x0590, 0x05ff ],
    "arabic"      => [ 0x0600, 0x06ff ],
    "syriac"      => [ 0x0700, 0x074f ],
    "controlpics" => [ 0x2400, 0x2426 ],
);

sub showRange2 {
    my ($sec) = @_;
    my $min = 0x0000;
    my $max = 0x001F;
    $sec = lc($sec);
    if (defined $namedRanges{$sec}) {
        #printf("entry: '%s'...'%s'\n", $namedRanges{$sec}->[0], $namedRanges{$sec}->[1]);
        $min = $namedRanges{$sec}->[0];
        $max = $namedRanges{$sec}->[1];
    }
    elsif ($sec =~ /^\s*(0?x?[0-9a-f]+)\W+(0?x?[0-9a-f]+)\s*$/) {
        #printf("Parsed '$chart' to '$1' and '$2'.\n");
        $min = $1;
        $max = $2;
        $min = ($min =~ m/^0/) ? oct($min) : int($min);
        $max = ($max =~ m/^0/) ? oct($max) : int($max);
        #printf("Parsed '$chart' to $min and $max.\n");
    }
    else {
        print "Can't parse --chart choice '$sec'. Named choices include: " .
            join(", ", keys(%namedRanges)) . ".\n";
        return;
    }
    printf("Character mnemonics and names for chars in %s [U+%05x...U+%05x]:\n",
        $sec, $min, $max);
    if ($max < $min) {
        print "    ******* Range is out of order *******\n";
        return;
    }
    for (my $n=$min; $n<=$max; $n++) {
        showOne($n);
    }
}


###############################################################################
# Display info for all the characters in a given range in a grid.
#
sub showTable {
    my ($first, $last) = @_;
    my $perRow = 16;
    my $f = $perRow * int(($first+0.0)/$perRow);
    my $l = ($perRow * ceil(($last+0.0)/$perRow)) - 1;

    my $buf = "          ";
    for (my $i=0; $i<$perRow; $i++) {
        $buf .= sprintf("%4x", $i);
    }
    print("$buf\n");
    for (my $i=$f; $i<$l; $i+=$perRow) {
        $buf = sprintf(" U+%05x: ", $i);
        for (my $j=0; $j<$perRow; $j++) {
            my $n = $i+$j;
            if ($n <= 32) { $n += 0x2400; }  # Control pictures
            my $c = chr($n);
            $buf .= sprintf("   %s", $c);
        }
        print("$buf\n");
    }
}


###############################################################################
# Make a nicely-formatted binary display of the code point.
#
sub getBinary {
    my ($n) = @_;
    my $rc = "";
    while ($n > 0) {
        my $n0 = $n & 0x0F;
        $n = $n>>4;
        my $n1 = $n & 0x0F;
        $n = $n>>4;
        $rc = sprintf("%04b_%04b %s", $n1, $n0, $rc);
    }
    $rc =~ s/\s+$//;
    return($rc);
}


###############################################################################
# Find all Unicode characters, per --findString, --findRegex, or --findBlock.
# Generate a list of all we found, in a specified --listFormat.
# This is slow.
#
sub findMatchingCharacters {
    my ($target) = @_;  # Target argument
    #warn sprintf("Searching for '%s'.\n", $target);
    my $lastBlockFound = '';
    my $nfound = 0;
    my $s = '';
    for (my $i=$minU; $i<=$maxU; $i++) {
        if (!$quiet && ($i % 0x10000)==0) {
            warn sprintf("...starting Unicode plane at %s...\n", hexDisp($i));
        }
        my $iname = charnames::viacode($i);
        if (!$iname) { next; }  # Undefined (probably?)

        if ($findRegex) {
            if ($iname !~ m/$target/i) { next; }
        }
        elsif ($findBlock) {
            my $cblock = charblock($i);
            #warn(sprintf("Block of %s is '%s'\n", uDisp($i), charblock($i)));
            # TODO: Check UCD's prop_value_aliases() function, too.
            if ($cblock !~ /$target/i) { next; }
            if ($cblock ne $lastBlockFound) {
                print("\n******* New matching block: '$cblock':\n");
                $lastBlockFound = $cblock;
            }
        }
        elsif ($findString) {
            if (index($iname, uc($target)) < 0) { next; }
        }
        elsif ($findSet) {
            if (chr($i) !~ /$target/) { next; }
        }
        else {
            die "Not sure what we're trying to --find...\n";
        }
        $nfound++;

        # Generate the right --listFormat.
        # This is really annoying for COMBINING characters.
        #
        if ($listFormat eq "PLAIN") {
            printf("%s\t%s\n", uDisp($i), $iname);
        }
        elsif ($listFormat eq "LITERAL") {             # DEFAULT
            printf("%s  %s  %s\n", uDisp($i), chr($i), $iname);
        }
        elsif ($listFormat eq "STRING") {              # Printed below
            $s .= ($i == 0x27) ? "\\'" : chr($i);
        }
        elsif ($listFormat eq "REGEX") {               # Printed below
            # TODO: Add code to coalesce ranges
            my $noEsc = ($i > 31 && $i < 128 && index("-^]", chr($i)) == -1);
            $s .= ($noEsc) ? chr($i) : getPyForm($i, 128);
        }
        elsif ($listFormat eq "PERL") {
            printf("    %s => '%s',\n", hexDisp($i), $iname);
        }
        elsif ($listFormat eq "PYTHONN") {
            printf("    %s: '%s',\n", hexDisp($i), $iname);
        }
        elsif ($listFormat eq "PYTHONS") {
            printf("    %s(%s) +  # '%s'\n", $pyFunction, hexDisp($i), $iname);
        }
        elsif ($listFormat eq "PYTHONU") {
            printf("    %s +   # '%s'\n", pyDisp($i), $iname);
        }
        elsif ($listFormat eq "PYTHONC") {
            printf("    %s(%s): '%s',\n", $pyFunction, hexDisp($i), $iname);
        }
        elsif ($listFormat eq "INFO") {
            print "\n";
            showOne($i);
        }
        elsif ($listFormat eq "HTML") {
            my $rec = "<tr>\n"
                . sprintf("    <td class='char'>%s</td>\n", entDisp($i))
                . sprintf("    <td class='hex'>%s</td>\n", uDisp($i))
                . sprintf("    <td class='name'>%s</td>\n", $iname)
                . "</tr>\n";
            print $rec;
        }
        else {
            die "Unknown --listFormat '$listFormat'. \n";
        }
    }
    
    # For ones that accumulate without printing, print them now.
    if ($listFormat eq "STRING") {
        print("    '" . $s . "'\n");
    }
    elsif ($listFormat eq "REGEX") {
        print("    [" . $s . "]\n");
    }

    my $msg = sprintf(
        "%d matches found from %s to %s (see --minU and --maxU).",
        $nfound, uDisp($minU), uDisp($maxU));
    if ($nfound<1 && $maxU < 0x10000) {
        $msg .= " Trying raising --maxU to 0x1FFFF?";
    }
    print ("$msg\n");
    return;
} # findMatchingCharacters


###############################################################################
# Display just one character, with unified output formatting.
#
# Note: The widths aren't right for big unicode stuff.
#
sub showOne {
    my ($n) = @_;
    my $n2 = 0;
    my $c = chr($n);

    if ($cp1252 && $n>=128 && $n<160) {
        $n2 = cp1252ToUnicode($n);
    }
    if ($short) {
        pline(sprintf(" %6s", "'" . getShortName($n2 ? $n2:$n) . "'"));
    }

    if ($long) {
        showUnicodeInfo($n);
    }

    if ($literal) {
        my $lit = "";
        if ($n<32) {
            $lit = "(control: " . $C0names[$n];
            if ($n>0 && $n<26) { $lit .= ", ^" . substr($upper,$n-1,1); }
            $lit .= ") ";
        }
        else {
            $lit = $c;
        }
        pline("Literal:", $lit);
    }

    my $bases = "";
    if ($binary)  { $bases .= getBinary($n) . " ";    }
    if ($octal)   { $bases .= sprintf("o%05o ",$n);    }
    if ($decimal) { $bases .= sprintf("d%05d ",$n);    }
    if ($hex)     { $bases .= sprintf("x%05x ",$n);    }
    if ($bases) {
        pline("Bases:", $bases);
    }

    if ($utf8) {  # Show UTF info
        my $utfForm = getUTF8local($n2 ? $n2:$n, "\\x");
        my $uriForm = getUTF8local($n2 ? $n2:$n, "%");
        my $okURI = (index($URIchars, $c) >= 0) ? 1:0;
        my $spURI = (index($URIspecials, $c) >= 0) ? 1:0;
        if ($okURI) { $uriForm = "ok as literal"; }
        elsif ($spURI) { $uriForm = "special"; }
        pline("Unicode:", sprintf(
            "%s, utf8 %s, URI (%s), Python %s",
            uDisp($n), $utfForm, $uriForm, getPyForm($n)));
    }

    if ($entities) {
        if ($n<32 && $n!=9 && $n!=10 && $n!=13) {
            pline("Entities:", "[not a legal XML character]");
        }
        else {
            my $entName = HTML::Entities::encode($c);
            if ($entName =~ m/^&#/) { $entName = "-NO HTML NAMED ENTITY-"; }
            pline("Entities:", sprintf("&#%d; &#x%x; %s", $n, $n, $entName));
        }
    }

    if ($iconv && $n>=128) {
        my $asc = $iconvConverter->convert($c);
        if (defined $asc && $asc) {
            pline("Nearest ASCII:", $asc);
        }
        else {
            pline("Nearest ASCII:", "[none]");
        }
    }

    if ($jargon && defined $unixJargon{$c}) {
        pline("Unix jargon:", $unixJargon{$c});
    }
} # showOne

# Convert characters to Python-style backslash hex escapes.
# If the second argument is given, just return the literal char for codepoints < it
# (but C0 controls are always escaped anyway).
sub getPyForm {
    my ($n, $minToEscape) = @_;
    if (!$minToEscape) { $minToEscape = 128; }
    if ($n < $minToEscape && $n > 31) { return chr($n); }
    if ($n <= 0xFF) { return sprintf("\\x%02x", $n); }
    if ($n <= 0xFFFF) { return sprintf("\\u%04x", $n); }
    return sprintf("\\U%08x", $n);
}

sub pline {
    my ($label, $data) = @_;
    printf("    %-18s %s\n", $label, $data || "");
}

sub showUnicodeInfo {
    my ($n) = @_;
    print("\n");
    if ($n >= 0x000080 && $n < 0x0000a0) {
        pline("WARNING:", "Not a Unicode graphical code point (C1 control char)");
    }
    if (!isUnicodeCodePoint($n)) {
        pline("WARNING:", "Not a Unicode code point");
    }
    else {
        pline("Unicode Name:", charnames::viacode($n) || "-NOT FOUND-");
        my $cat = charinfo($n)->{category} || "-NOT FOUND-";
        if ($cat) { $cat .= " ($unicodeCategories{$cat})"; }
        pline("Unicode Category:", $cat);
        pline("Unicode Script: ", charscript(uDisp($n)));
        pline("Unicode Block:  ", charblock($n));
    }
    my $pnum = $n >> 16;
    my $pname = "";
    if    ($pnum == 16) { $pname = "Supplementary Private Use Area B"; }
    elsif ($pnum == 15) { $pname = "Supplementary Private Use Area A"; }
    elsif ($pnum == 14) { $pname = "Supplementary Special-purpose"; }
    elsif ($pnum >=  3) { $pname = "Unassigned"; }
    elsif ($pnum ==  2) { $pname = "Supplementary Ideographic"; }
    elsif ($pnum ==  1) { $pname = "Supplementary Multilingual"; }
    elsif ($pnum ==  0) { $pname = "Basic Multilingual"; }
    else                { $pname = "-UNKNOWN-"; }
    pline("Unicode Plane:" , $pnum . ": " . $pname);

    if ($n == 0xEFBFBD) {
        pline("WARNING:", "UTF8 of U+FFFD (Replacement Character)?");
    }
} # showUnicodeInfo


###############################################################################
#
sub getShortName {
    my ($n) = @_;
    my $name = "";
    if ($n>=256) {
        return(charnames::viacode($n) ||"???");
    }
    else {
        if ($n < 32)     { $name = $C0names[$n];     }
        elsif ($n < 128) { $name = $G0names[$n-32];  }
        elsif ($n < 160) { $name = $C1names[$n-128]; }
        elsif ($n < 256) { $name = $G1names[$n-160]; }
    }
    return($name);
}


###############################################################################
# Define local names, in case we want shorter forms than viacode gives.
#
sub setupShortCharacterNames {
    @C0names = (
              "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
               "BS",  "HT",  "LF",  "VT",  "FF",  "CR",  "SO",  "SI",
              "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
              "CAN",  "EM", "SUB", "ESC",  "FS",  "GS",  "RS",  "US",
               "SP");

    @C1names = (
              "PAD", "HOP",  "BPH", "NBH", "IND", "NEL", "SSA", "ESA",
              "HTS", "HTJ",  "VTS", "PLD", "PLU",  "RI", "SS2", "SS3",
              "DCS", "PU1",  "PU2", "STS", "CCH",  "MW", "SPA", "EPA",
              "SOS", "SGCI", "SCI", "CSI",  "ST", "OSC",  "PM", "APC",
              "NBS");

    @G0names = (
        # 0x20
        "SPACE",
        "BANG",
        "QUOTATION MARK",
        "HASH",
        "DOLLAR",
        "GRAPES",
        "AMP",
        "POP",
        "LEFT PARENTHESIS",
        "RIGHT PARENTHESIS",
        "ASTERISK",
        "PLUS SIGN",
        "COMMA",
        "HYPHEN-MINUS",
        "FULL STOP",
        "SOLIDUS",

        # 0x30
        "DIGIT ZERO",
        "DIGIT ONE",
        "DIGIT TWO",
        "DIGIT THREE",
        "DIGIT FOUR",
        "DIGIT FIVE",
        "DIGIT SIX",
        "DIGIT SEVEN",
        "DIGIT EIGHT",
        "DIGIT NINE",
        "COLON",
        "SEMICOLON",
        "LESS-THAN SIGN",
        "EQUALS SIGN",
        "GREATER-THAN SIGN",
        "QUESTION MARK",

        # 0x40
        "COMMERCIAL AT",
        "LATIN CAPITAL LETTER A",
        "LATIN CAPITAL LETTER B",
        "LATIN CAPITAL LETTER C",
        "LATIN CAPITAL LETTER D",
        "LATIN CAPITAL LETTER E",
        "LATIN CAPITAL LETTER F",
        "LATIN CAPITAL LETTER G",
        "LATIN CAPITAL LETTER H",
        "LATIN CAPITAL LETTER I",
        "LATIN CAPITAL LETTER J",
        "LATIN CAPITAL LETTER K",
        "LATIN CAPITAL LETTER L",
        "LATIN CAPITAL LETTER M",
        "LATIN CAPITAL LETTER N",
        "LATIN CAPITAL LETTER O",

        # 0x50
        "LATIN CAPITAL LETTER P",
        "LATIN CAPITAL LETTER Q",
        "LATIN CAPITAL LETTER R",
        "LATIN CAPITAL LETTER S",
        "LATIN CAPITAL LETTER T",
        "LATIN CAPITAL LETTER U",
        "LATIN CAPITAL LETTER V",
        "LATIN CAPITAL LETTER W",
        "LATIN CAPITAL LETTER X",
        "LATIN CAPITAL LETTER Y",
        "LATIN CAPITAL LETTER Z",
        "LEFT SQUARE BRACKET",
        "REVERSE SOLIDUS",
        "RIGHT SQUARE BRACKET",
        "CIRCUMFLEX ACCENT",
        "LOW LINE",

        # 0x60
        "GRAVE ACCENT",
        "LATIN SMALL LETTER A",
        "LATIN SMALL LETTER B",
        "LATIN SMALL LETTER C",
        "LATIN SMALL LETTER D",
        "LATIN SMALL LETTER E",
        "LATIN SMALL LETTER F",
        "LATIN SMALL LETTER G",
        "LATIN SMALL LETTER H",
        "LATIN SMALL LETTER I",
        "LATIN SMALL LETTER J",
        "LATIN SMALL LETTER K",
        "LATIN SMALL LETTER L",
        "LATIN SMALL LETTER M",
        "LATIN SMALL LETTER N",
        "LATIN SMALL LETTER O",

        # 0x70
        "LATIN SMALL LETTER P",
        "LATIN SMALL LETTER Q",
        "LATIN SMALL LETTER R",
        "LATIN SMALL LETTER S",
        "LATIN SMALL LETTER T",
        "LATIN SMALL LETTER U",
        "LATIN SMALL LETTER V",
        "LATIN SMALL LETTER W",
        "LATIN SMALL LETTER X",
        "LATIN SMALL LETTER Y",
        "LATIN SMALL LETTER Z",
        "LEFT CURLY BRACKET",
        "VERTICAL LINE",
        "RIGHT CURLY BRACKET",
        "TILDE",
        "<control> DEL DELETE"
        );
    ($G0names[126-32] eq "TILDE") || die
        "ord: Internal G0 name table screwed up.\n";
} # setupCharacterNames


###############################################################################
#
sub setupUnixJargon {
    %unixJargon = (
        "!" => "Common: bang; pling; excl; not; shriek; ball-bat. " .
               "Rare: factorial; exclam; smash; cuss; boing; yell; wow; hey; " .
               "wham; eureka; spark-spot; soldier, control",
        "\"" => "Common: double quote; quote. " .
               "Rare: literal mark; double-glitch; snakebite; dirk; " .
               "rabbit-ears; double prime",
        "#" => "Common: number sign; pound; pound sign; hash; " .
               "sharp; crunch; hex; mesh. " .
               "Rare: grid; cross-hatch; octothorpe; flash; pig-pen; " .
               "tic-tac-toe; scratchmark; thud; thump; splat",
        "\$" => "Common: dollar. " .
               "Rare: currency symbol; buck; cash; bling; string (from BASIC); " .
               "escape (when used as the echo of ASCII ESC); ding; cache; big money",
        "%" => "Common: percent; mod; grapes. " .
               "Rare: double-oh-seven",
        "&" => "Common: amp; amper; and, and sign. " .
               "Rare: address (from C); reference (from C++); andpersand; " .
               "bitand; background (from sh(1) ); pretzel",
        "'" => "Common: single quote; quote. " .
               "Rare: prime; glitch; tick; irk; pop; spark;",
        "(" => "Common: l paren; l parenthesis; leftight; open; paren; " .
               "o paren; o parenthesis; l parenthesis; l banana. " .
               "Rare: so; lparen; o round bracket, l round bracket, wax; " .
               "parenthisey; l ear",
        ")" => " Common: r paren; r parenthesis; right; close; the-sis; " .
               "c paren; c parenthesis; r parenthesis; r banana. " .
               "Rare: al-ready; rparen; c round bracket, r round bracket, " .
               "wane; unparenthisey; r ear",
        "*" => "Common: star; splat. " .
               "Rare: wildcard; gear; dingle; mult; spider; aster; " .
               "times; twinkle; glob; Nathan Hale",
        "+" => "Common: add. " .
               "Rare: cross; intersection",
        "," => "" .
               "Rare: tail",
        "-" => "Common: dash. " .
               "Rare: worm; option; dak; bithorpe",
        "." => "Common: dot; point. " .
               "Rare: radix point; full stop; spot",
        "/" => "Common: slash; stroke; forward slash. " .
               "Rare: diagonal; solidus; over; slak; virgule; slat",
        ":" => "Common: . " .
               "Rare: dots; two-spot",
        ";" => "Common: semi. " .
               "Rare: weenie; hybrid, pit-thwong",
        "<" => "Common: bra; l angle; l angle bracket; l broket. " .
               "Rare: from; read from; comes-from; in; crunch; tic; angle",
        ">" => "Common: ket; r angle; r angle bracket; r broket. " .
               "Rare: into, towards; write to; gozinta; out; zap; tac; right angle",
        "=" => "Common: gets; takes. " .
               "Rare: quadrathorpe; half-mesh",
        "?" => "Common: query; ques . " .
               "Rare: quiz; whatmark; what; wildchar; huh; hook; " .
               "buttonhook; hunchback",
        "@" => "Common: at sign; at; strudel. " .
               "Rare: each; vortex; whorl; whirlpool; cyclone; snail; " .
               "ape; cat; rose; cabbage;",
        "V" => "" .
               "Rare: book",
        "[" => "Common: l square bracket; l bracket; bracket. " .
               "Rare: square; U turn",
        "]" => "Common: r square bracket; r bracket; unbracket. " .
               "Rare: un-square; U turn back",
        "\\" => "Common: backslash, hack, whack; escape; reverse slash; " .
               "slosh; backslant; backwhack. " .
               "Rare: bash; reversed virgule; reverse solidus; rsol; backslat",
        "^" => "Common: hat; control; uparrow; caret. " .
               "Rare: xor sign, chevron; shark; shark-fin; to the; " .
               "to the power of; fang; pointer",
        "_" => "Common: underscore; underbar; under. " .
               "Rare: score; backarrow; skid; flatworm",
        "`" => "Common: backquote; left quote; left single quote; " .
               "open quote; grave. " .
               "Rare: backprime; backspark; unapostrophe; birk; blugle; " .
               "back tick; back glitch; push; quasiquote",
        "{" => "Common: o brace; l brace; l squiggly; l squiggly bracket, " .
               "l squiggly brace; l curly bracket, l curly brace. " .
               "Rare: brace; curly-curly; l squirrelly; embrace",
        "}" => "Common: c brace; r brace; r squiggly; r squiggly bracket, " .
               "r squiggly brace; r curly bracket; r curly brace. " .
               "Rare: unbrace; un-curly; r squirrelly; bracelet",
        "|" => "Common: bar; or; or-bar; v-bar; pipe; vertical bar. " .
               "Rare: gozinta; thru; pipesinta; spike",
        "~" => "Common: squiggle; twiddle; not. " .
               "Rare: approx; wiggle; swung dash; enyay"
        );
} # setupUnixJargon


# Also add:
my $foo = [
    # aeox schwa hklmnpst; i=1d62, r=1d63, u=1d64, v=1d65, j=2c7c
    [ 'subscript latin upper (...209c)',    0x02090 ],
    # superscripts: i=2071
    # [ 'subscript latin lower',                 ],
    [ 'fullwidth latin upper',              0x0ff21 ],
    [ 'fullwidth latin lower',              0x0ff41 ],
];

# See mathAlphanumerics.py for more details.
#
sub setupMathAlphabets {  # Not really all *math*....
    my %mathMissing = (
        0x1d455 => 0x210e,  # ITALIC LOWER H (PLanck Constant)
        0x1d49d => 0x212c,  # SCRIPT UPPER B
        0x1d4a0 => 0x2130,  # SCRIPT UPPER E
        0x1d4a1 => 0x2131,  # SCRIPT UPPER F
        0x1d4a3 => 0x210b,  # SCRIPT UPPER H
        0x1d4a4 => 0x2110,  # SCRIPT UPPER I
        0x1d4a7 => 0x2112,  # SCRIPT UPPER L
        0x1d4a8 => 0x2133,  # SCRIPT UPPER M
        #  => 0x2118 script upper p
        0x1d4ad => 0x211b,  # SCRIPT UPPER R
        0x1d4ba => 0x212f,  # SCRIPT LOWER e
        0x1d4bc => 0x0261,  # SCRIPT LOWER g
        # ??? 0x1d4bc => 0x2113,  # SCRIPT LOWER l
        0x1d4c4 => 0x2134,  # SCRIPT LOWER o
        0x1d506 => 0x212d,  # FRAKTUR UPPER C
        0x1d50b => 0x210c,  # FRAKTUR UPPER H
        0x1d50c => 0x2111,  # FRAKTUR UPPER I
        0x1d50d => 0x1,  # FRAKTUR UPPER J
        0x1d515 => 0x211c,  # FRAKTUR UPPER R
        0x1d51d => 0x2128,  # FRAKTUR UPPER Z
        0x1d53a => 0x2102,  # DOUBLE-STRUCK UPPER C
        0x1d53f => 0x210d,  # DOUBLE-STRUCK UPPER H
        0x1d545 => 0x2115,  # DOUBLE-STRUCK UPPER N
        0x1d547 => 0x2119,  # DOUBLE-STRUCK UPPER P
        0x1d548 => 0x211a,  # DOUBLE-STRUCK UPPER Q
        0x1d549 => 0x211d,  # DOUBLE-STRUCK UPPER R
        0x1d551 => 0x2124,  # DOUBLE-STRUCK UPPER Z
        # 2145-2149 double struck italics
        # 213c-40 double struck pi, gamma, sigma
    );

    $mathAlphabets = [
         [ 'parenthesized LOWER',               'LOWER', 0x0249c ],
         [ 'circled UPPER',                     'UPPER', 0x024b6 ],
         [ 'circled LOWER',                     'LOWER', 0x024d0 ],
         [ 'parenthesized UPPER',               'UPPER', 0x1f110 ],
         [ 'squared upper',                     'UPPER', 0x1f130 ],
         [ 'negative circled UPPER',            'UPPER', 0x1f150 ],
         [ 'negative squared UPPER',            'UPPER', 0x1f170 ],
         [ 'regional indicator symbol UPPER',   'UPPER', 0x1f1e6 ],

         # 'mathematical...',
         [ 'M. bold UPPER',                     'UPPER', 0x1d400 ],
         [ 'M. bold LOWER',                     'LOWER', 0x1d41A ],
         [ 'M. italic UPPER',                   'UPPER', 0x1d434 ],
         [ 'M. italic LOWER',                   'LOWER', 0x1d44e ],  # h
         [ 'M. bold italic UPPER',              'UPPER', 0x1d468 ],
         [ 'M. bold italic LOWER',              'LOWER', 0x1d482 ],
         [ 'M. script UPPER',                   'UPPER', 0x1d49C ],  # BEFHILMPR
         [ 'M. script LOWER',                   'LOWER', 0x1d4B6 ],  # eglo
         [ 'M. bold script UPPER',              'UPPER', 0x1d4D0 ],
         [ 'M. bold script LOWER',              'LOWER', 0x1d4EA ],
         [ 'M. fraktur UPPER',                  'UPPER', 0x1d504 ],  # CHIJRZ
         [ 'M. fraktur LOWER',                  'LOWER', 0x1d51E ],
         [ 'M. double-struck UPPER',            'UPPER', 0x1d538 ],  # CHNPQRZ
         [ 'M. double-struck LOWER',            'LOWER', 0x1d552 ],
         [ 'M. bold fraktur UPPER',             'UPPER', 0x1d56C ],
         [ 'M. bold fraktur LOWER',             'LOWER', 0x1d586 ],
         [ 'M. sans-serif UPPER',               'UPPER', 0x1d5A0 ],
         [ 'M. sans-serif LOWER',               'LOWER', 0x1d5ba ],
         [ 'M. sans-serif bold UPPER',          'UPPER', 0x1d5D4 ],
         [ 'M. sans-serif bold LOWER',          'LOWER', 0x1d5EE ],
         [ 'M. sans-serif italic UPPER',        'UPPER', 0x1d608 ],
         [ 'M. sans-serif italic LOWER',        'LOWER', 0x1d622 ],
         [ 'M. sans-serif bold italic UPPER',   'UPPER', 0x1d63C ],
         [ 'M. sans-serif bold italic LOWER',   'LOWER', 0x1d656 ],
         [ 'M. monospace UPPER',                'UPPER', 0x1d670 ],
         [ 'M. monospace LOWER',                'LOWER', 0x1d68a ],
         # black-letter capital chirz: 0x210c...0x212d = fraktur
         # subscripts: iruv, grk bgrfx 0x1d62...0x1d6a
         #
    ];
    # (couple extras at 1d6a4, dotless i, j)
    # greek upper+lower:
    $mathGreeks = [
        [ 'bold UPPER',                         'UPPER', 0x1d6a8 ],
        [ 'bold LOWER',                         'LOWER', 0x1d6c2 ],
        [ 'italic UPPER',                       'UPPER', 0x1d6e2 ],
        [ 'italic LOWER',                       'LOWER', 0x1d6fc ],
        [ 'bold italic UPPER',                  'UPPER', 0x1d71c ],
        [ 'bold italic LOWER',                  'LOWER', 0x1d736 ],
        [ 'sans serif bold UPPER',              'UPPER', 0x1d756 ],
        [ 'sans serif bold LOWER',              'LOWER', 0x1d770 ],
        [ 'sans serif bold italic UPPER',       'UPPER', 0x1d790 ],
        [ 'sans serif bold italic LOWER',       'LOWER', 0x1d7AA ],
    ];
    $digitSets = [
        # Following go from 0...9 or as indicated
        [ 'bold DIGITS',                        'DIGITS', 0x1d7Ce, 0, 9 ],
        [ 'double struck DIGITS',               'DIGITS', 0x1d7d8, 0, 9 ],
        [ 'sans serif DIGITS',                  'DIGITS', 0x1d7e2, 0, 9 ],
        [ 'sans serif bold DIGITS',             'DIGITS', 0x1d7ec, 0, 9 ],
        [ 'monospace DIGITS',                   'DIGITS', 0x1d7f6, 0, 9 ],
        [ 'subscript latin digits',             'DIGITS', 0x02080, 0, 9 ],
        [ 'fullwidth latin digits',             'DIGITS', 0x0ff11, 0, 9 ],
        [ 'superscript latin digits',           'DIGITS', 0x02070, 0, 0 ],
        [ 'superscript latin digits',           'DIGITS', 0x000b9, 1, 1 ],
        [ 'superscript latin digits',           'DIGITS', 0x000b2, 2, 3 ],
        [ 'superscript latin digits',           'DIGITS', 0x02074, 4, 9 ],

        [ 'circled DIGITS',                     'DIGITS', 0x024ea, 0,  0 ],
        [ 'circled DIGITS',                     'DIGITS', 0x02460, 1, 20 ],
        [ 'parenthesized DIGITS',               'DIGITS', 0x02474, 1, 20 ],
        [ 'full stopped DIGITS',                'DIGITS', 0x1f100, 0,  0 ],
        [ 'full stopped DIGITS',                'DIGITS', 0x02488, 1, 20 ],
        [ 'double circled DIGITS',              'DIGITS', 0x024f5, 1, 10 ],
        [ 'dingbat circled sans-serif DIGITS',  'DIGITS', 0x02780, 1, 10 ],
        [ 'dingbat negative circled sans-serif DIGITS','DIGITS',0x0278a,1,10],
        [ 'negative circled DIGITS',            'DIGITS', 0x024ff, 0,  0 ],
        [ 'dingbat negative circled DIGITS',    'DIGITS', 0x02776, 1, 10 ],
        [ 'negative circled DIGITS',            'DIGITS', 0x024eb, 11, 20 ],
        [ 'FULLWIDTH DIGITS',                   'DIGITS', 0x0ff10, 0, 9 ],

        [ 'arabic-indic DIGITS',                'DIGITS', 0x00660, 0, 9 ],
        [ 'extended arabic-indic DIGITS',       'DIGITS', 0x006F0, 0, 9 ],
        [ 'nko DIGITS',                         'DIGITS', 0x007c0, 0, 9 ],
        [ 'devanagari DIGITS',                  'DIGITS', 0x00966, 0, 9 ],
        [ 'bengali DIGITS',                     'DIGITS', 0x009e6, 0, 9 ],
        [ 'gurmukhi DIGITS',                    'DIGITS', 0x00a66, 0, 9 ],
        [ 'gujarati DIGITS',                    'DIGITS', 0x00aE6, 0, 9 ],
        [ 'oriya DIGITS',                       'DIGITS', 0x00b66, 0, 9 ],
        [ 'tamil DIGITS',                       'DIGITS', 0x00bE6, 0, 9 ],
        [ 'telugu DIGITS',                      'DIGITS', 0x00c66, 0, 9 ],
        [ 'kannada DIGITS',                     'DIGITS', 0x00cE6, 0, 9 ],
        [ 'malayalam DIGITS',                   'DIGITS', 0x00d66, 0, 9 ],
        [ 'sinhala lith DIGITS',                'DIGITS', 0x00dE6, 0, 9 ],
        [ 'thai DIGITS',                        'DIGITS', 0x00E50, 0, 9 ],
        [ 'lao DIGITS',                         'DIGITS', 0x00Ed0, 0, 9 ],
        [ 'tibetan DIGITS',                     'DIGITS', 0x00f20, 0, 9 ],
        [ 'MYANMAR DIGITS',                     'DIGITS', 0x01040, 0, 9 ],
        [ 'MYANMAR SHAN DIGITS',                'DIGITS', 0x01090, 0, 9 ],
        [ 'KHMER DIGITS',                       'DIGITS', 0x017e0, 0, 9 ],
        [ 'MONGOLIAN DIGITS',                   'DIGITS', 0x01810, 0, 9 ],
        [ 'LIMBU DIGITS',                       'DIGITS', 0x01946, 0, 9 ],
        [ 'NEW TAI LUE DIGITS',                 'DIGITS', 0x019d0, 0, 9 ],
        [ 'TAI THAM HORA DIGITS',               'DIGITS', 0x01a80, 0, 9 ],
        [ 'TAI THAM THAM DIGITS',               'DIGITS', 0x01a90, 0, 9 ],
        [ 'BALINESE DIGITS',                    'DIGITS', 0x01b50, 0, 9 ],
        [ 'SUNDANESE DIGITS',                   'DIGITS', 0x01bb0, 0, 9 ],
        [ 'LEPCHA DIGITS',                      'DIGITS', 0x01c40, 0, 9 ],
        [ 'OL CHIKI DIGITS',                    'DIGITS', 0x01c50, 0, 9 ],
        [ 'IDEOGRAPHIC NUMBER',                 'DIGITS', 0x03007, 0, 9 ],
        [ 'VAI DIGITS',                         'DIGITS', 0x0a620, 0, 9 ],
        [ 'SAURASHTRA DIGITS',                  'DIGITS', 0x0a8d0, 0, 9 ],
        [ 'COMBINING DEVANAGARI DIGITS',        'DIGITS', 0x0a8e0, 0, 9 ],
        [ 'KAYAH LI DIGITS',                    'DIGITS', 0x0a900, 0, 9 ],
        [ 'JAVANESE DIGITS',                    'DIGITS', 0x0a9d0, 0, 9 ],
        [ 'CHAM DIGITS',                        'DIGITS', 0x0aa50, 0, 9 ],
        [ 'MEETEI MAYEK DIGITS',                'DIGITS', 0x0abf0, 0, 9 ],

        [ 'roman numerals',                     'DIGITS', 0x02160, 1, 12 ],
        [ 'small roman numerals',               'DIGITS', 0x02170, 1, 12 ],
        [ 'playing cards, spades',              'DIGITS', 0x1f0a1, 1, 10 ],
        [ 'playing cards, hearts',              'DIGITS', 0x1f0b1, 1, 10 ],
        [ 'playing cards, diamonds',            'DIGITS', 0x1f0c1, 1, 10 ],
        [ 'playing cards, clubs',               'DIGITS', 0x1f0d1, 1, 10 ],
        [ 'mahjong tiles, characters',          'DIGITS', 0x1f007, 1,  9 ],
        [ 'mahjong tiles, bamboos',             'DIGITS', 0x1f010, 1,  9 ],
        [ 'mahjong tiles, circles',             'DIGITS', 0x1f019, 1,  9 ],
    ];
}

###############################################################################
# See http://www.microsoft.com/typography/unicode/1252.htm
#
sub cp1252ToUnicode {
    my ($char) = @_;
    return($cp1252{$char});
}


###############################################################################
# Main
#
print "";
binmode(STDOUT, ":encoding(utf8)");
if ($ENV{"LANG"} !~ m/UTF-?8/i) {
    warn "Warning: LANG environment variable does not mention UTF-8.\n";
}

if ($chart) {
    showRange2($chart);
    exit;
}
if ($C0) { showRange2("c0"); exit; }
if ($G0) { showRange2("g0"); exit; }
if ($C1) { showRange2("c1"); exit; }
if ($G1) { showRange2("g1"); exit; }

if ($table) {
    my $rgRef = $namedRanges{$table};
    my @rg = @{$rgRef};
    showTable($rg[0], $rg[1]);
    exit;
}
if ($digits) {
    showDigits();
    exit;
}
if ($math) {
    showMathAlphabets();
    exit;
}

if ($pairs) {
    searchForSymmetricPairs();
}

(scalar(@ARGV)) ||
    die "No character or mnemonic found (see -h for"
        . " information on hard-to-type characters).\n";

while (my $origName = shift) {
    my $name = $origName;
    my $n = 0;
    if (length($name) == 1) {
        $n = ord($name);
    }
    else { # Search for the name
        my $entRef = '&'.$name.';';
        my $c = HTML::Entities::decode($entRef);
        if ($c ne $entRef) {                # HTML entity (case sensitive!)
            $n = ord($c);
            printf("Found HTML entity name '$name' = %s.\n", uDisp($n));
        }
        $name = uc($name);                  # C0 name?
        for (my $i=0; $i<scalar @C0names; $i++) {
            if ($C0names[$i] eq $name) { $n = $i; last; }
        }
        if (!$n) {                          # C1 name?
            for (my $i=0; $i<scalar @C1names; $i++) {
                if (lc($C1names[$i]) eq lc($name)) { $n = $i+128; last; }
            }
        }
        if (!$n) {                          # Long Unicode name
            (my $tname = uc($name)) =~ s/_+/ /g;
            $n = charnames::vianame($tname);
        }
        if (!$n) {                          # Unix Jargon name?
            for my $k (keys %unixJargon) {
                if ($unixJargon{$k} =~ m/\b$name\b/i) { $n = ord($k); last; }
            }
        }
        if (!$n) {                          # Number per se?
            if ($name =~ m/^0?x[0-9a-f]+$/i) {
                $name =~ s/0?x//i; $n = hex($name);
            }
            elsif ($name =~ m/^0[0-7]+$/)    { $n = oct($name); }
            elsif ($name =~ m/^[0-9]+$/)     { $n = $name - 0; }
        }
        if (!$n) {                          # ^J C-S
            if ($name =~ m/^(\^|C-)([A-Z])$/) {
                $n = index($upper, $2) + 1;
            }
        }
        if (!$n) {                          # %e2809c
            if ($name =~ m/^%([0-9A-F]+)$/i) {
                if (length($name) % 2 == 0) {
                    warn "%utf8 must have even length after '%'.\n";
                }
                else {
                    my $uriForm = substr($name,1);
                    $uriForm =~ s/(..)/%$1/g;
                    my $txt = Encode::decode('utf8', uri_unescape($uriForm));
                    $n = ord(substr($txt,0,1));
                }
            }
        }

        if (!$n || $findBlock || $findString || $findRegex || $findSet) {
            warn "Character mnemonic '$origName' (length "
                . length($name) . ") not found.\n";
            ($findBlock)  && warn "    Searching for block '$name'...\n";
            ($findRegex)  && warn "    Searching for regex '$name'...\n";
            ($findSet)    && warn "    Searching for regex set '$origName'...\n" .
                "    [[ --findSet is still experimental ]]\n";
            ($findString) && warn "    Searching for string '$name'...\n";
            findMatchingCharacters($origName);
            next;
        }
    }
    showOne($n);
} # while

exit;
